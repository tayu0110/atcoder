pub use __cargo_equip::prelude::*;

use proconio::*;
use static_modint::{Mod1000000007, StaticModint};

type Modint = StaticModint<Mod1000000007>;

fn main() {
    input! {n: usize, mut a: [u32; n]}
    a.sort();

    let mut res = Modint::zero();
    for (i, a) in a.into_iter().map(|a| Modint::raw(a)).enumerate() {
        res += Modint::raw(2).pow(i as u64) * a;
    }

    println!("{}", res)
}

// The following code was expanded by `cargo-equip`.

///  # Bundled libraries
/// 
///  - `modint-common 0.1.0 (path+████████████████████████████████████████████████████)` published in **missing** licensed under `CC0-1.0` as `crate::__cargo_equip::crates::__modint_common_0_1_0`
///  - `static-modint 0.1.0 (path+████████████████████████████████████████████████████)` published in **missing** licensed under `CC0-1.0` as `crate::__cargo_equip::crates::static_modint`
///  - `zero-one 0.1.0 (path+████████████████████████████████████████████████)`          published in **missing** licensed under `CC0-1.0` as `crate::__cargo_equip::crates::__zero_one_0_1_0`
#[cfg_attr(any(), rustfmt::skip)]
#[allow(unused)]
mod __cargo_equip {
    pub(crate) mod crates {
        pub mod __modint_common_0_1_0 {mod modulo{use std::{arch::x86_64::__m256i,fmt::Debug,marker,mem::transmute};macro_rules!newtons_method{($mod:expr)=>{{let inv=$mod.wrapping_mul(2u32.wrapping_sub($mod.wrapping_mul($mod)));let inv=inv.wrapping_mul(2u32.wrapping_sub($mod.wrapping_mul(inv)));let inv=inv.wrapping_mul(2u32.wrapping_sub($mod.wrapping_mul(inv)));let inv=inv.wrapping_mul(2u32.wrapping_sub($mod.wrapping_mul(inv)));inv.wrapping_mul(2u32.wrapping_sub($mod.wrapping_mul(inv)))}};}pub trait Modulo:Clone+marker::Copy+PartialEq+Eq+Debug{const N:u32;const N2:u32=Self::N.wrapping_mul(2);const N_INV:u32=newtons_method!(Self::N);const N_PRIME:u32=Self::N_INV.wrapping_neg();const R:u32=((1u64<<32)%Self::N as u64)as u32;const R2:u32=((Self::N as u64).wrapping_neg()%Self::N as u64)as u32;const PRIM_ROOT:u32;const NX8:__m256i=unsafe{transmute([Self::N;8])};const N2X8:__m256i=unsafe{transmute([Self::N2;8])};const N_INVX8:__m256i=unsafe{transmute([Self::N_INV;8])};const N_PRIMEX8:__m256i=unsafe{transmute([Self::N_PRIME;8])};const RX8:__m256i=unsafe{transmute([Self::R;8])};const R2X8:__m256i=unsafe{transmute([Self::R2;8])};}macro_rules!impl_modulo{($({$name:ident,$modulo:literal,$prim_root:literal},)*)=>{$(#[derive(Debug,Clone,marker::Copy,PartialEq,Eq)]pub enum$name{}impl Modulo for$name{const N:u32=$modulo;const PRIM_ROOT:u32=$prim_root;})*};}impl_modulo!({Mod167772161,167772161,3},{Mod377487361,377487361,7},{Mod469762049,469762049,3},{Mod595591169,595591169,3},{Mod645922817,645922817,3},{Mod754974721,754974721,11},{Mod880803841,880803841,26},{Mod897581057,897581057,3},{Mod998244353,998244353,3},{Mod1000000007,1000000007,5},{Mod1107296257,1107296257,10},{Mod1224736769,1224736769,3},{Mod1300234241,1300234241,3},{Mod1484783617,1484783617,5},{Mod1711276033,1711276033,29},{Mod1811939329,1811939329,13},{Mod2013265921,2013265921,31},{Mod2088763393,2088763393,5},{Mod2113929217,2113929217,5},{Mod2130706433,2130706433,3},{Mod2281701377,2281701377,3},{Mod2483027969,2483027969,3},{Mod2533359617,2533359617,3},{Mod2634022913,2634022913,3},{Mod2717908993,2717908993,5},{Mod2868903937,2868903937,35},{Mod2885681153,2885681153,3},{Mod3221225473,3221225473,5},{Mod3238002689,3238002689,3},{Mod3489660929,3489660929,3},{Mod3892314113,3892314113,3},{Mod3942645761,3942645761,3},{Mod4076863489,4076863489,7},{Mod4194304001,4194304001,3},);}mod montgomery{use super::modulo::Modulo;use std::arch::x86_64::{__m256i,_mm256_add_epi32 as addi32,_mm256_add_epi64 as addi64,_mm256_and_si256 as and256,_mm256_blend_epi32 as blendi32,_mm256_cmpeq_epi32 as eqi32,_mm256_cmpgt_epi32,_mm256_max_epu32 as maxu32,_mm256_min_epu32,_mm256_mul_epu32 as mulu32,_mm256_mullo_epi32 as mulloi32,_mm256_or_si256,_mm256_setzero_si256 as zero256,_mm256_shuffle_epi32 as shufi32,_mm256_sub_epi32 as subi32,_mm256_xor_si256 as xor256,};const THRESHOLD:u32=1<<30;#[inline]pub const fn mreduce<M:Modulo>(t:u32)->u32{if M::N>THRESHOLD{let(t,f)=(((t.wrapping_mul(M::N_INV)as u64).wrapping_mul(M::N as u64)>>32)as u32).overflowing_neg();t.wrapping_add(M::N&(f as u32).wrapping_neg())}else{((t as u64+t.wrapping_mul(M::N_PRIME)as u64*M::N as u64)>>32)as u32}}#[inline]#[target_feature(enable="avx2")]pub unsafe fn mreducex8<M:Modulo>(t:__m256i)->__m256i{if M::N>THRESHOLD{let t_ninv=mulloi32(t,M::N_INVX8);let t_ninv_n_lo=mulu32(t_ninv,M::NX8);let t_ninv_n_hi=mulu32(shufi32(t_ninv,0b10_11_00_01),M::NX8);let mr=blendi32(shufi32(t_ninv_n_lo,0b10_11_00_01),t_ninv_n_hi,0b10101010);let zero=zero256();let mask=eqi32(mr,zero);let mask=and256(M::NX8,xor256(mask,eqi32(mask,mask)));subi32(mask,mr)}else{let t_np=mulloi32(t,M::N_PRIMEX8);let res_lo=addi64(mulu32(t_np,M::NX8),blendi32(t,zero256(),0b10101010));let res_hi=addi64(mulu32(shufi32(t_np,0b10_11_00_01),M::NX8),blendi32(shufi32(t,0b10_11_00_01),zero256(),0b10101010));blendi32(shufi32(res_lo,0b10_11_00_01),res_hi,0b10101010)}}#[inline]pub const fn mmul<M:Modulo>(a:u32,b:u32)->u32{let t=a as u64*b as u64;if M::N>THRESHOLD{let(t,f)=((t>>32)as u32).overflowing_sub((((t as u32).wrapping_mul(M::N_INV)as u64).wrapping_mul(M::N as u64)>>32)as u32);t.wrapping_add(M::N&(f as u32).wrapping_neg())}else{((t+(t as u32).wrapping_mul(M::N_PRIME)as u64*M::N as u64)>>32)as u32}}#[inline]#[target_feature(enable="avx2")]pub unsafe fn mmulx8<M:Modulo>(a:__m256i,b:__m256i)->__m256i{if M::N>THRESHOLD{let t1=mulu32(a,b);let t2=mulu32(shufi32(a,0b10_11_00_01),shufi32(b,0b10_11_00_01));let t_modinv=mulloi32(blendi32(t1,shufi32(t2,0b10_11_00_01),0b10101010),M::N_INVX8);let c=blendi32(shufi32(mulu32(t_modinv,M::NX8),0b10_11_00_01),mulu32(shufi32(t_modinv,0b10_11_00_01),M::NX8),0b10101010);let t=blendi32(shufi32(t1,0b10_11_00_01),t2,0b10101010);let one=eqi32(c,c);let mask=and256(M::NX8,xor256(one,eqi32(_mm256_min_epu32(t,c),c)));addi32(mask,subi32(t,c))}else{let t_lo=mulu32(a,b);let t_hi=mulu32(shufi32(a,0b10_11_00_01),shufi32(b,0b10_11_00_01));let t_np=mulloi32(blendi32(t_lo,shufi32(t_hi,0b10_11_00_01),0b10101010),M::N_PRIMEX8);let n64x4=blendi32(M::NX8,zero256(),0b10101010);let res_lo=addi64(t_lo,mulu32(t_np,n64x4));let res_hi=addi64(t_hi,mulu32(shufi32(t_np,0b10_11_00_01),n64x4));blendi32(shufi32(res_lo,0b10_11_00_01),res_hi,0b10101010)}}#[inline]pub const fn mrestore<M:Modulo>(t:u32)->u32{t-if M::N<=THRESHOLD{M::N&((t>=M::N)as u32).wrapping_neg()}else{0}}#[inline]#[target_feature(enable="avx2")]pub unsafe fn mrestorex8<M:Modulo>(t:__m256i)->__m256i{if M::N>THRESHOLD{t}else{let mask=_mm256_or_si256(_mm256_cmpgt_epi32(t,M::NX8),eqi32(t,M::NX8));subi32(t,and256(mask,M::NX8))}}#[inline]pub const fn madd<M:Modulo>(a:u32,b:u32)->u32{if M::N>THRESHOLD{let(t,fa)=a.overflowing_add(b);let(u,fs)=t.overflowing_sub(M::N);let f=(fa||!fs)as u32;f*u+(1-f)*t}else{let res=a+b;res-(((res>=M::N2)as u32).wrapping_neg()&M::N2)}}#[inline]#[target_feature(enable="avx2")]pub unsafe fn maddx8<M:Modulo>(a:__m256i,b:__m256i)->__m256i{if M::N>THRESHOLD{let diff=subi32(M::NX8,a);let mask=eqi32(diff,maxu32(diff,b));let val=addi32(subi32(a,M::NX8),b);addi32(val,and256(mask,M::NX8))}else{let res=addi32(a,b);let mask=eqi32(res,maxu32(res,M::N2X8));subi32(res,and256(M::N2X8,mask))}}#[inline]pub const fn msub<M:Modulo>(a:u32,b:u32)->u32{let(res,f)=a.overflowing_sub(b);if M::N>THRESHOLD{res.wrapping_add(M::N&(f as u32).wrapping_neg())}else{res.wrapping_add(M::N2&(f as u32).wrapping_neg())}}#[inline]#[target_feature(enable="avx2")]pub unsafe fn msubx8<M:Modulo>(a:__m256i,b:__m256i)->__m256i{if M::N>THRESHOLD{let mask=eqi32(b,maxu32(a,b));let c_neg=subi32(a,b);addi32(c_neg,and256(M::NX8,mask))}else{let mask=_mm256_cmpgt_epi32(b,a);addi32(subi32(a,b),and256(M::N2X8,mask))}}}pub use modulo::*;pub use montgomery::*;}
        pub mod static_modint {use crate::__cargo_equip::preludes::static_modint::*;pub use modint_common::*;use std::marker::{self,PhantomData};use std::ops::{Add,AddAssign,Div,DivAssign,Mul,MulAssign,Sub,SubAssign};use zero_one::{One,Zero};#[derive(Clone,Copy,PartialEq,Eq)]pub struct StaticModint<M:Modulo>{val:u32,_p:PhantomData<fn()->M>,}impl<M:Modulo>One for StaticModint<M>{#[inline]fn one()->Self{Self::one()}}impl<M:Modulo>Zero for StaticModint<M>{#[inline]fn zero()->Self{Self::zero()}}impl<M:Modulo>StaticModint<M>{#[inline]pub const fn new(val:u64)->Self{StaticModint{val:(val%M::N as u64)as u32,_p:PhantomData}}pub const fn new_signed(val:i64)->Self{StaticModint{val:val.rem_euclid(M::N as i64)as u32,_p:PhantomData}}#[inline]pub const fn raw(val:u32)->Self{debug_assert!(val<M::N);StaticModint{val,_p:marker::PhantomData}}#[inline]pub const fn zero()->Self{StaticModint{val:0,_p:marker::PhantomData}}#[inline]pub const fn one()->Self{StaticModint{val:1,_p:marker::PhantomData}}#[inline]pub const fn modulo()->u32{M::N}#[inline]pub const fn val(&self)->u32{self.val}pub const fn pow(&self,mut exp:u64)->Self{let(mut val,mut res)=(self.val as u64,1);while exp>0{if exp&1==1{res=(res*val)%M::N as u64;}val=(val*val)%M::N as u64;exp>>=1;}Self{val:res as u32,_p:PhantomData}}#[inline]pub const fn inv(&self)->Self{self.pow(M::N as u64-2)}#[inline]pub const fn nth_root(n:u32)->Self{debug_assert!(n==1<<n.trailing_zeros());StaticModint::raw(M::PRIM_ROOT).pow((M::N as u64-1)/n as u64)}#[inline]pub const fn add_raw(&self,rhs:u32)->Self{debug_assert!(rhs<M::N);let res=self.val+rhs;StaticModint::raw(if res>=M::N{res-M::N}else{res})}#[inline]pub const fn sub_raw(&self,rhs:u32)->Self{debug_assert!(rhs<M::N);let(res,f)=self.val.overflowing_sub(rhs);StaticModint::raw(if f{res.wrapping_add(M::N)}else{res})}#[inline]pub const fn mul_raw(&self,rhs:u32)->Self{debug_assert!(rhs<M::N);StaticModint::new(self.val as u64*rhs as u64)}#[inline]pub const fn div_raw(&self,rhs:u32)->Self{debug_assert!(rhs<M::N);self.mul_raw(StaticModint::<M>::raw(rhs).inv().val)}}impl<M:Modulo>Default for StaticModint<M>{fn default()->Self{StaticModint::zero()}}impl<M:Modulo>std::fmt::Debug for StaticModint<M>{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{write!(f,"{}",self.val)}}impl<M:Modulo>std::fmt::Display for StaticModint<M>{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{write!(f,"{}",self.val)}}impl<M:Modulo>Add for StaticModint<M>{type Output=Self;fn add(self,rhs:Self)->Self::Output{self.add_raw(rhs.val)}}impl<M:Modulo>AddAssign for StaticModint<M>{fn add_assign(&mut self,rhs:Self){*self=*self+rhs;}}impl<M:Modulo>Sub for StaticModint<M>{type Output=Self;fn sub(self,rhs:Self)->Self::Output{self.sub_raw(rhs.val)}}impl<M:Modulo>SubAssign for StaticModint<M>{fn sub_assign(&mut self,rhs:Self){*self=*self-rhs;}}impl<M:Modulo>Mul for StaticModint<M>{type Output=Self;fn mul(self,rhs:Self)->Self::Output{self.mul_raw(rhs.val)}}impl<M:Modulo>MulAssign for StaticModint<M>{fn mul_assign(&mut self,rhs:Self){*self=*self*rhs;}}impl<M:Modulo>Div for StaticModint<M>{type Output=Self;fn div(self,rhs:Self)->Self::Output{debug_assert!(rhs.val!=0);self*rhs.inv()}}impl<M:Modulo>DivAssign for StaticModint<M>{fn div_assign(&mut self,rhs:Self){debug_assert!(rhs.val!=0);*self*=rhs.inv()}}impl<M:Modulo>From<u32>for StaticModint<M>{fn from(value:u32)->Self{Self::new(value as u64)}}impl<M:Modulo>From<u64>for StaticModint<M>{fn from(value:u64)->Self{Self::new(value)}}impl<M:Modulo>From<i32>for StaticModint<M>{fn from(value:i32)->Self{Self::new_signed(value as i64)}}impl<M:Modulo>From<i64>for StaticModint<M>{fn from(value:i64)->Self{Self::new_signed(value)}}pub fn combination<M:Modulo>(size:u32)->impl Fn(u32,u32)->StaticModint<M>{let mut fact=vec![StaticModint::<M>::one()];fact.append(&mut(1..=size).scan(StaticModint::<M>::one(),|s,v|{*s*=StaticModint::new(v as u64);Some(*s)}).collect(),);let inv=fact[size as usize].inv();let mut ifact=vec![inv];ifact.append(&mut(1..=size).rev().scan(inv,|s,v|{*s*=StaticModint::new(v as u64);Some(*s)}).collect(),);ifact.reverse();move|n:u32,k:u32|{if n<k{StaticModint::zero()}else{fact[n as usize]*ifact[k as usize]*ifact[(n-k)as usize]}}}}
        pub mod __zero_one_0_1_0 {mod one{pub trait One{fn one()->Self;}macro_rules!impl_one_integer{($($t:ty)*)=>{$(impl One for$t{fn one()->$t{1}})*};}impl_one_integer!(i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize);macro_rules!impl_one_float{($($t:ty)*)=>{$(impl One for$t{fn one()->$t{1.0}})*};}impl_one_float!(f32 f64);}mod zero{pub trait Zero{fn zero()->Self;}macro_rules!impl_zero_integer{($($t:ty)*)=>{$(impl Zero for$t{fn zero()->$t{0}})*};}impl_zero_integer!(i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize);macro_rules!impl_zero_float{($($t:ty)*)=>{$(impl Zero for$t{fn zero()->$t{0.0}})*};}impl_zero_float!(f32 f64);}pub use one::*;pub use zero::*;}
    }

    pub(crate) mod macros {
        pub mod __modint_common_0_1_0 {}
        pub mod static_modint {}
        pub mod __zero_one_0_1_0 {}
    }

    pub(crate) mod prelude {pub use crate::__cargo_equip::crates::*;}

    mod preludes {
        pub mod __modint_common_0_1_0 {}
        pub mod static_modint {pub(in crate::__cargo_equip)use crate::__cargo_equip::crates::{__modint_common_0_1_0 as modint_common,__zero_one_0_1_0 as zero_one};}
        pub mod __zero_one_0_1_0 {}
    }
}
