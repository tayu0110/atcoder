{
	"UnionFind": {
		"prefix": "UnionFind",
		"body": [
			"struct UnionFind {",
			"\ttree: Vec<i32>",
			"}",
			"impl UnionFind {",
			"\tfn new(size: usize) -> Self {",
			"\t\tlet mut tree = vec![];",
			"\t\tfor _ in 0..size {",
			"\t\t\ttree.push(-1);",
			"\t\t}",
			"\t\tUnionFind { tree }",
			"\t}",
			"\t#[allow(dead_code)]",
			"\tfn root(&self, index: usize) -> usize {",
			"\t\tif self.tree[index] < 0 {",
			"\t\t\tindex",
			"\t\t} else {",
			"\t\t\tself.root(self.tree[index] as usize)",
			"\t\t}",
			"\t}",
			"\t#[allow(dead_code)]",
			"\tfn size(&self, index: usize) -> usize {",
			"\t\t-self.tree[self.root(index)] as usize",
			"\t}",
			"\t#[allow(dead_code)]",
			"\tfn is_same(&self, left: usize, right: usize) -> bool {",
			"\t\tself.root(left) == self.root(right)",
			"\t}",
			"\t#[allow(dead_code)]",
			"\tfn merge(&mut self, left: usize, right: usize) -> bool {",
			"\t\tlet mut rl = self.root(left);",
			"\t\tlet mut rr = self.root(right);",
			"\t\tif rl == rr {",
			"\t\t\treturn false;",
			"\t\t}",
			"\t\tif self.tree[rl] > self.tree[rr] {",
			"\t\t\tlet tmp = rl;",
			"\t\t\trl = rr;",
			"\t\t\trr = tmp;",
			"\t\t}",
			"\t\tself.tree[rl] += self.tree[rr];",
			"\t\tself.tree[rr] = rl as i32;",
			"\t\treturn true;",
			"\t}",
			"}"
		]
	},
	"Mint": {
		"prefix": "Modint",
		"body": [
			"const MOD: i64 = 1000000007;",
			"#[derive(Clone, Copy, PartialEq, Eq)]",
			"struct Mint {",
			"\tval: i64,",
			"\tmodulo: i64",
			"}",
			"#[allow(dead_code)]",
			"impl Mint {",
			"\tfn new(val: i64) -> Self { let modulo = MOD; Mint { val: val % modulo, modulo } }",
			"\tfn val(&self) -> i64 { self.val % self.modulo }",
			"\tfn pow(&self, mut exp: i64) -> Self {",
			"\t\tlet mut val = self.val;",
			"\t\tlet mut res = 1;",
			"\t\twhile exp > 0 {",
			"\t\t\tif exp % 2 == 1 {",
			"\t\t\t\tres = (res * val) % self.modulo;",
			"\t\t\t}",
			"\t\t\tval = (val * val) % self.modulo;",
			"\t\t\texp /= 2;",
			"\t\t}",
			"\t\tSelf { val: res, modulo: self.modulo }",
			"\t}",
			"\tfn inv(&self) -> Self { self.pow(self.modulo - 2) }",
			"}",
			"impl Default for Mint { fn default() -> Self { Mint { val: 0, modulo: MOD }}}",
			"impl std::fmt::Debug for Mint { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, \"{}\", self.val) } }",
			"impl std::fmt::Display for Mint { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, \"{}\", self.val) } }",
			"impl std::ops::Add for Mint { type Output = Self; fn add(self, rhs: Self) -> Self::Output { Self::new(self.val + rhs.val) } }",
			"impl std::ops::AddAssign for Mint { fn add_assign(&mut self, rhs: Self) { *self = *self + rhs; } }",
			"impl std::ops::Sub for Mint { type Output = Self; fn sub(self, rhs: Self) -> Self::Output { Self::new(self.val - rhs.val + self.modulo) } }",
			"impl std::ops::SubAssign for Mint { fn sub_assign(&mut self, rhs: Self) { *self = *self - rhs; } }",
			"impl std::ops::Mul for Mint { type Output = Self; fn mul(self, rhs: Self) -> Self::Output { Self::new(self.val * rhs.val) } }",
			"impl std::ops::MulAssign for Mint { fn mul_assign(&mut self, rhs: Self) { *self = *self * rhs; } }",
			"impl std::ops::Div for Mint { type Output = Self; fn div(self, rhs: Self) -> Self::Output { if rhs.val == 0 { panic!(\"0 division\"); } else { self * rhs.inv() } } }",
			"impl std::ops::DivAssign for Mint { fn div_assign(&mut self, rhs: Self) { if rhs.val == 0 { panic!(\"0 division\"); } else { *self *= rhs.inv() } } }",
			"struct Combination {",
			"\tfact: Vec<Mint>,",
			"\tifact: Vec<Mint>",
			"}",
			"impl Combination {",
			"\t#[allow(dead_code)]",
			"\tfn new(size: usize) -> Self {",
			"\t\tlet mut fact = vec![Mint::new(0); size+1];",
			"\t\tlet mut ifact = vec![Mint::new(0); size+1];",
			"\t\tfact[0] = Mint::new(1);",
			"\t\tifact[0] = Mint::new(1);",
			"\t\tfor v in 1..size+1 {",
			"\t\t\tfact[v] = Mint::new(fact[v-1].val) * Mint::new(v as i64);",
			"\t\t}",
			"\t\tifact[size] = fact[size].inv();",
			"\t\tfor v in (1..size).rev() {",
			"\t\t\tifact[v] = ifact[v+1] * Mint::new(v as i64 + 1) ;",
			"\t\t}",
			"\t\tSelf { fact, ifact }",
			"\t}",
			"\t#[allow(dead_code)]",
			"\tfn get(&self, n: usize, k: usize) -> Mint {",
			"\t\tif n < k {",
			"\t\t\tMint::new(0)",
			"\t\t} else {",
			"\t\t\tself.fact[n] * self.ifact[k] * self.ifact[n-k]",
			"\t\t}",
			"\t}",
			"}"
		]
	},
	"next_permutation": {
		"prefix": "next_permutation",
		"body": [
			"fn next_permutation<T: Copy + Clone + Eq + Ord>(list: &mut Vec<T>) -> bool {",
			"\tlet len = list.len();",
			"\tfor i in (0..len-1).rev() {",
			"\t\tif list[i] < list[i+1] {",
			"\t\t\tlet mut j = list.len() - 1;",
			"\t\t\twhile list[i] > list[j] {",
			"\t\t\t\tj -= 1;",
			"\t\t\t}",
			"\t\t\tlet tmp = list[i];",
			"\t\t\tlist[i] = list[j];",
			"\t\t\tlist[j] = tmp;",
			"\t\t\tlist[i+1..len].sort();",
			"\t\t\treturn true;",
			"\t\t}",
			"\t\tif i == 0 {",
			"\t\t\tlist.reverse();",
			"\t\t}",
			"\t}",
			"\tfalse",
			"}"
		]
	},
	"Matrix": {
		"prefix": "Matrix",
		"body": [
			"#[derive(Clone)]",
			"struct Matrix {",
			"\trow: usize,",
			"\tcolumn: usize,",
			"\tmatrix: Box<[Mint]>",
			"}",
			"#[allow(dead_code)]",
			"impl Matrix {",
			"\tfn new(row: usize, column: usize) -> Self { assert!(row > 0 && column > 0); Matrix { row, column, matrix: (vec![Default::default(); row * column]).into_boxed_slice() } }",
			"\tfn row(&self) -> usize { self.row }",
			"\tfn column(&self) -> usize { self.column }",
			"\tfn set(&mut self, row: usize, column: usize, val: Mint) { assert!(row < self.row() && column < self.column()); let c = self.column(); self.matrix[c*row+column] = val; }",
			"\tfn get(&self, row: usize, column: usize) -> Mint { assert!(row < self.row() && column < self.column()); self.matrix[row*self.column() + column] }",
			"\tfn id(size: usize) -> Self {",
			"\t\tlet mut matrix = (vec![Default::default(); size*size]).into_boxed_slice();",
			"\t\tfor i in 0..size { matrix[i*size+i] = Mint::new(1); }",
			"\t\tSelf { row: size, column: size, matrix }",
			"\t}",
			"\tfn add(&self, rhs: &Self) -> Self {",
			"\t\tassert!(self.row() == rhs.row() && self.column() == rhs.column());",
			"\t\tlet matrix = self.matrix.iter().zip(rhs.matrix.iter()).map(|(x, y)| *x + *y).collect();",
			"\t\tSelf { row: self.row(), column: self.column(), matrix }",
			"\t}",
			"\tfn sub(&self, rhs: &Self) -> Self {",
			"\t\tassert!(self.row() == rhs.row() && self.column() == rhs.column());",
			"\t\tlet matrix = self.matrix.iter().zip(rhs.matrix.iter()).map(|(x, y)| *x - *y).collect();",
			"\t\tSelf { row: self.row(), column: self.column(), matrix }",
			"\t}",
			"\tfn mul(&self, rhs: &Self) -> Self {",
			"\t\tunsafe { self.mul_sub(rhs) }",
			"\t}",
			"\t#[target_feature(enable = \"avx2\")]",
			"\tunsafe fn mul_sub(&self, rhs: &Self) -> Self {",
			"\t\tlet (lrow, lcolumn, rrow, rcolumn) = (self.row(), self.column(), rhs.row(), rhs.column());",
			"\t\tassert!(lcolumn == rrow);",
			"\t\tlet mut matrix = (vec![Default::default(); lrow*rcolumn]).into_boxed_slice();",
			"\t\tfor (s, t) in matrix.chunks_exact_mut(rcolumn).zip(self.matrix.chunks_exact(lcolumn)) {",
			"\t\t\tfor (v, u) in t.iter().zip(rhs.matrix.chunks_exact(rcolumn)) {",
			"\t\t\t\tfor (x, y) in s.iter_mut().zip(u.iter()) {",
			"\t\t\t\t\t*x += *v * *y;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\tSelf { row: lrow, column: rcolumn, matrix }",
			"\t}",
			"\tfn pow(&self, mut n: usize) -> Self {",
			"\t\tassert!(self.row() == self.column());",
			"\t\tlet (mut ret, mut now) = (Self::id(self.row()), self.clone());",
			"\t\twhile n > 0 {",
			"\t\t\tif n % 2 == 1 { ret = ret.mul(&now); }",
			"\t\t\tnow = now.mul(&now);",
			"\t\t\tn /= 2;",
			"\t\t}",
			"\t\tret",
			"\t}",
			"}"
		]
	},
	"FenwickTree": {
		"prefix": "FenwickTree",
		"body": [
			"struct FenwickTree<T> {",
			"\tsize: usize,",
			"\tdef_val: T,",
			"\ttree: Vec<T>",
			"}",
			"#[allow(dead_code)]",
			"impl<T> FenwickTree<T>",
			"where T: Sized + Clone + Copy + Default + std::ops::AddAssign + std::ops::Sub<Output = T> + std::ops::SubAssign + PartialOrd",
			"{",
			"\tfn new(size: usize, def_val: T) -> Self {",
			"\t\tSelf { size: size+1, def_val, tree: vec![def_val; size+1] }",
			"\t}",
			"\tfn add(&mut self, idx: usize, val: T) {",
			"\t\tlet mut idx = idx as i64;",
			"\t\tidx += 1;",
			"\t\twhile (idx as usize) < self.size {",
			"\t\t\tself.tree[idx as usize] += val;",
			"\t\t\tidx += idx & -idx;",
			"\t\t}",
			"\t}",
			"\tfn get_sum_sub(&self, r: usize) -> T {",
			"\t\tlet mut r = r as i64;",
			"\t\tif (r as usize) >= self.size {",
			"\t\t\tr = self.size as i64 - 1;",
			"\t\t}",
			"\t\tlet mut res = self.def_val;",
			"\t\twhile r > 0 {",
			"\t\t\tres += self.tree[r as usize];",
			"\t\t\tr -= r & -r;",
			"\t\t}",
			"\t\tres",
			"\t}",
			"\tfn get_sum(&self, l: usize, r: usize) -> T {",
			"\t\tself.get_sum_sub(r) - self.get_sum_sub(l)",
			"\t}",
			"\tfn lower_bound(&self, mut val: T) -> usize {",
			"\t\tlet mut now = 0;",
			"\t\tlet mut n = 1;",
			"\t\twhile n * 2 <= self.size {",
			"\t\t\tn *= 2;",
			"\t\t}",
			"\t\twhile n > 0 {",
			"\t\t\tif now + n < self.size && self.tree[now + n] < val {",
			"\t\t\t\tval -= self.tree[now + n];",
			"\t\t\t\tnow += n;",
			"\t\t\t}",
			"\t\t\tn /= 2;",
			"\t\t}",
			"\t\tnow",
			"\t}",
			"\tfn upper_bouond(&self, mut val: T) -> usize {",
			"\t\tlet mut now = 0;",
			"\t\tlet mut n = 1;",
			"\t\twhile n * 2 < self.size {",
			"\t\t\tn *= 2;",
			"\t\t}",
			"\t\twhile n > 0 {",
			"\t\t\tif now + n < self.size && self.tree[now + n] <= val {",
			"\t\t\t\tval -= self.tree[now + n];",
			"\t\t\t\tnow += n;",
			"\t\t\t}",
			"\t\t\tn /= 2;",
			"\t\t}",
			"\t\tnow",
			"\t}",
			"}"
		]
	},
	"gcd": {
		"prefix": "gcd",
		"body": [
			"fn gcd(x: usize, y: usize) -> usize {",
			"\tif y == 0 {",
			"\t\tx",
			"\t} else {",
			"\t\tgcd(y, x % y)",
			"\t}",
			"}"
		]
	},
	"lcm": {
		"prefix": "lcm",
		"body": [
			"fn lcm(x: usize, y: usize) -> usize {",
			"\tx / gcd(x, y) * y",
			"}"
		]
	},
	"PermanentDualSegTree": {
		"prefix": "PermanentDualSegTree",
		"body": [
			"struct PermanentDualSegTree",
			"{",
			"\tsize: usize,",
			"\ttree: Vec<Vec<(usize, usize)>>",
			"}",
			"impl PermanentDualSegTree",
			"{",
			"\tfn new(size: usize) -> Self {",
			"\t\tlet mut n = 1;",
			"\t\twhile n < size {",
			"\t\t\tn <<= 1;",
			"\t\t}",
			"\t\tSelf { size: n, tree: vec![vec![]; n*2] }",
			"\t}",
			"\tfn update_sub(&mut self, l: usize, r: usize, val: (usize, usize), now: usize, a: usize, b: usize) {",
			"\t\tif b <= l || r <= a {",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tif l <= a && b <= r {",
			"\t\t\tif self.tree[now].is_empty() {",
			"\t\t\t\tself.tree[now].push(val);",
			"\t\t\t} else {",
			"\t\t\t\tlet (_, sum) = &self.tree[now].last().unwrap().clone();",
			"\t\t\t\tself.tree[now].push((val.0, val.1 + *sum));",
			"\t\t\t}",
			"\t\t} else {",
			"\t\t\tself.update_sub(l, r, val, now*2,   a, (a+b) / 2);",
			"\t\t\tself.update_sub(l, r, val, now*2+1, (a+b) / 2, b);",
			"\t\t}",
			"\t}",
			"\tfn update(&mut self, l: usize, r: usize, val: (usize, usize)) {",
			"\t\tself.update_sub(l, r, val, 1, 0, self.size);",
			"\t}",
			"\tfn get(&self, idx: usize, gen: usize) -> usize {",
			"\t\tlet mut idx = idx + self.size;",
			"\t\tlet mut res = 0;",
			"\t\twhile idx > 0 {",
			"\t\t\tif self.tree[idx].len() > 0 {",
			"\t\t\t\tlet mut l = -1;",
			"\t\t\t\tlet mut r = self.tree[idx].len() as i32;",
			"\t\t\t\twhile r - l > 1 {",
			"\t\t\t\t\tlet m = (r + l) / 2;",
			"\t\t\t\t\tif self.tree[idx][m as usize].0 <= gen {",
			"\t\t\t\t\t\tl = m;",
			"\t\t\t\t\t} else {",
			"\t\t\t\t\t\tr = m;",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t\tres += self.tree[idx].last().unwrap().1;",
			"\t\t\t\tif l >= 0 {",
			"\t\t\t\t\tres -= self.tree[idx][l as usize].1;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\tidx >>= 1;",
			"\t\t}",
			"\t\tres",
			"\t}",
			"}"
		]
	},
	"MapWrapper": {
		"prefix": "MapWrapper",
		"body": [
			"struct MapWrapper<K, V> { map: std::collections::BTreeMap<K, V> }",
			"#[allow(dead_code)]",
			"impl<K, V> MapWrapper<K, V> where K: Ord {",
			"\tfn new() -> Self { Self { map: std::collections::BTreeMap::new() } }",
			"\tfn len(&self) -> usize { self.map.len() }",
			"\tfn contains(&self, key: &K) -> bool { self.map.contains_key(key) }",
			"\tfn remove(&mut self, key: &K) { if self.map.contains_key(key) { self.map.remove(key).unwrap(); } }",
			"\tfn clear(&mut self) { self.map.clear() }",
			"\tfn is_empty(&self) -> bool { self.map.is_empty() }",
			"\tfn first(&self) -> Option<(&K, &V)> { if self.is_empty() { None } else { self.map.iter().next() } }",
			"\tfn first_mut(&mut self) -> Option<(&K, &mut V)> { if self.is_empty() { None } else { self.map.iter_mut().next() } }",
			"\tfn last(&self) -> Option<(&K, &V)> { if self.is_empty() { None } else { self.map.iter().rev().next() } }",
			"\tfn last_mut(&mut self) -> Option<(&K, &mut V)> { if self.is_empty() { None } else { self.map.iter_mut().next() } }",
			"\tfn iter(&self) -> std::collections::btree_map::Iter<'_, K, V> { self.map.iter() }",
			"\tfn iter_mut(&mut self) -> std::collections::btree_map::IterMut<'_, K, V> { self.map.iter_mut() }",
			"}",
			"impl<K, V> std::ops::Index<K> for MapWrapper<K, V> where K: Ord {",
			"\ttype Output = V;",
			"\tfn index(&self, index: K) -> &Self::Output { &self.map[&index] }",
			"}",
			"impl<K, V> std::ops::IndexMut<K> for MapWrapper<K, V> where K: Ord, V: Default {",
			"\tfn index_mut(&mut self, index: K) -> &mut Self::Output { self.map.entry(index).or_insert(Default::default()) }",
			"}"
		]
	},
	"flow": {
		"prefix": "flow",
		"body": [
			"mod flow {",
			"\tpub const INF: i64 = 0x3f3f3f3f3f3f3f3f;",
			"\t#[derive(Clone, Copy)]",
			"\tstruct Edge {",
			"\t\tto: usize,",
			"\t\tcap: i64,",
			"\t\trev: usize",
			"\t}",
			"\timpl Edge {",
			"\t\tfn new(to: usize, cap: i64, rev: usize) -> Self { Self { to, cap, rev } }",
			"\t}",
			"\tpub struct Dinic {",
			"\t\tsize: usize,",
			"\t\tlevel: Vec<i32>,",
			"\t\titer: Vec<usize>,",
			"\t\tgraph: Vec<Vec<Edge>>",
			"\t}",
			"\t#[allow(dead_code)]",
			"\timpl Dinic {",
			"\t\tpub fn new(size: usize) -> Self { Self { size, level: vec![0; size], iter: vec![0; size], graph: vec![vec![]; size] } }",
			"\t\tpub fn set_edge(&mut self, from: usize, to: usize, cap: i64) {",
			"\t\t\tlet (rev_from, rev_to) = (self.graph[to].len(), self.graph[from].len());",
			"\t\t\tself.graph[from].push(Edge::new(to, cap, rev_from));",
			"\t\t\tself.graph[to].push(Edge::new(from, 0, rev_to));",
			"\t\t}",
			"\t\tfn bfs(&mut self, start: usize) {",
			"\t\t\tself.level = vec![-1; self.size];",
			"\t\t\tlet mut nt: std::collections::VecDeque<(usize, i32)> = std::collections::VecDeque::new();",
			"\t\t\tnt.push_back((start, 0i32));",
			"\t\t\twhile let Some((now, nd)) = nt.pop_front() {",
			"\t\t\t\tif self.level[now] >= 0 { continue; }",
			"\t\t\t\tself.level[now] = nd;",
			"\t\t\t\tself.graph[now].iter().for_each(|e| if e.cap > 0 && self.level[e.to] < 0 { nt.push_back((e.to, nd+1)) });",
			"\t\t\t}",
			"\t\t}",
			"\t\tfn dfs(&mut self, now: usize, target: usize, f: i64) -> i64 {",
			"\t\t\tif now == target { return f; }",
			"\t\t\tlet mut i = self.iter[now];",
			"\t\t\twhile i < self.graph[now].len() {",
			"\t\t\t\tlet e = self.graph[now][i];",
			"\t\t\t\tif e.cap > 0 && self.level[now] < self.level[e.to] {",
			"\t\t\t\t\tlet d = self.dfs(e.to, target, std::cmp::min(f, e.cap));",
			"\t\t\t\t\tif d > 0 {",
			"\t\t\t\t\t\tself.graph[now][i].cap -= d;",
			"\t\t\t\t\t\tself.graph[e.to][e.rev].cap += d;",
			"\t\t\t\t\t\tself.iter[now] = i;",
			"\t\t\t\t\t\treturn d;",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t\ti += 1;",
			"\t\t\t}",
			"\t\t\tself.iter[now] = i;",
			"\t\t\t0",
			"\t\t}",
			"\t\tpub fn flow(&mut self, start: usize, target: usize) -> i64 {",
			"\t\t\tlet mut res = 0;",
			"\t\t\tloop {",
			"\t\t\t\tself.bfs(start);",
			"\t\t\t\tif self.level[target] < 0 { return res; }",
			"\t\t\t\tself.iter = vec![0; self.size];",
			"\t\t\t\tloop {",
			"\t\t\t\t\tlet f = self.dfs(start, target, INF);",
			"\t\t\t\t\tif f <= 0 { break; }",
			"\t\t\t\t\tres += f;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tpub struct FordFullkerson {",
			"\t\tsize: usize,",
			"\t\tgraph: Vec<Vec<Edge>>",
			"\t}",
			"\t#[allow(dead_code)]",
			"\timpl FordFullkerson {",
			"\t\tpub fn new(size: usize) -> Self {",
			"\t\t\tSelf { size, graph: vec![vec![]; size] }",
			"\t\t}",
			"\t\tpub fn set_edge(&mut self, from: usize, to: usize, cap: i64) {",
			"\t\t\tlet f_size = self.graph[from].len();",
			"\t\t\tlet t_size = self.graph[to].len();",
			"\t\t\tself.graph[from].push(Edge::new(to, cap, t_size));",
			"\t\t\tself.graph[to].push(Edge::new(from, 0, f_size));",
			"\t\t}",
			"\t\tpub fn flow(&mut self, start: usize, goal: usize) -> i64 {",
			"\t\t\tlet mut res = 0;",
			"\t\t\tloop {",
			"\t\t\t\tlet mut used = vec![false; self.size];",
			"\t\t\t\tlet f = self.dfs(start, INF, goal, &mut used);",
			"\t\t\t\tif f == 0 { return res; }",
			"\t\t\t\tres += f;",
			"\t\t\t}",
			"\t\t}",
			"\t\tfn dfs(&mut self, now: usize, f: i64, goal: usize, used: &mut Vec<bool>) -> i64 {",
			"\t\t\tif now == goal { return f; }",
			"\t\t\tused[now] = true;",
			"\t\t\tfor i in 0..self.graph[now].len() {",
			"\t\t\t\tlet Edge { to, cap, rev } = self.graph[now][i];",
			"\t\t\t\tif used[to] || cap == 0 { continue; }",
			"\t\t\t\tlet res = self.dfs(to, std::cmp::min(f, cap), goal, used);",
			"\t\t\t\tif res == 0 { continue; }",
			"\t\t\t\tself.graph[to][rev].cap += res;",
			"\t\t\t\tself.graph[now][i].cap -= res;",
			"\t\t\t\treturn res;",
			"\t\t\t}",
			"\t\t\t0",
			"\t\t}",
			"\t}",
			"}",
			"#[allow(unused_imports)]",
			"use flow::FordFullkerson;",
			"#[allow(unused_imports)]",
			"use flow::Dinic;"
		]
	},
	"Bitset": {
		"prefix": "Bitset",
		"body": [
			"const BIT_SIZE: usize = 128;",
			"struct Bitset { size: usize, bits: Vec<u128> }",
			"#[allow(dead_code)]",
			"impl Bitset {",
			"\tfn new(size: usize) -> Self { Self { size, bits: vec![0; (size + BIT_SIZE - 1) / BIT_SIZE] } }",
			"\tfn set(&mut self, idx: usize) { assert!(idx < self.size); let (idx, bit) = (idx / BIT_SIZE, idx % BIT_SIZE); self.bits[idx] |= 1 << bit; }",
			"\tfn drop(&mut self, idx: usize) { assert!(idx < self.size); let (idx, bit) = (idx / BIT_SIZE, idx % BIT_SIZE); self.bits[idx] ^= 1 << bit; }",
			"\tfn flip(&mut self) {",
			"\t\tfor v in self.bits.iter_mut() { *v = !*v; }",
			"\t\tif self.size % BIT_SIZE != 0 { let sz = self.size % BIT_SIZE; *self.bits.last_mut().unwrap() &= (1 << (sz+1)) - 1; }",
			"\t}",
			"\tfn test(&self, idx: usize) -> bool { (self.bits[idx / BIT_SIZE] & (1u128 << (idx % BIT_SIZE))) != 0 }",
			"\tfn count_ones(&self) -> usize { let mut res = 0; for v in self.bits.iter() { res += v.count_ones() as usize; } res }",
			"\tfn bitwise_and(&self, rhs: &Bitset) -> Self {",
			"\t\tlet mut bits = vec![];",
			"\t\tfor (v, w) in self.bits.iter().zip(rhs.bits.iter()) { bits.push(v & w); }",
			"\t\tSelf { size: self.size, bits }",
			"\t}",
			"\tfn bitwise_or(&self, rhs: &Bitset) -> Bitset {",
			"\t\tlet mut bits = vec![];",
			"\t\tfor (v, w) in self.bits.iter().zip(rhs.bits.iter()) { bits.push(v | w); }",
			"\t\tSelf { size: self.size, bits }",
			"\t}",
			"\tfn bitwise_xor(&self, rhs: &Bitset) -> Self {",
			"\t\tlet mut bits = vec![];",
			"\t\tfor (v, w) in self.bits.iter().zip(rhs.bits.iter()) { bits.push(v ^ w); }",
			"\t\tSelf { size: self.size, bits }",
			"\t}",
			"}",
			"impl PartialEq for Bitset { fn eq(&self, other: &Self) -> bool { for (v, w) in self.bits.iter().zip(other.bits.iter()) { if v != w { return false; } } true } }",
			"impl Eq for Bitset { }",
			"impl PartialOrd for Bitset {",
			"\tfn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> { self.bits.partial_cmp(&other.bits) }",
			"\tfn lt(&self, other: &Self) -> bool { for (v, w) in self.bits.iter().zip(other.bits.iter()) { if v != w { return v < w; } } false }",
			"\tfn le(&self, other: &Self) -> bool { for (v, w) in self.bits.iter().zip(other.bits.iter()) { if v != w { return v < w; } } true }",
			"\tfn gt(&self, other: &Self) -> bool { for (v, w) in self.bits.iter().zip(other.bits.iter()) { if v != w { return v > w; } } false }",
			"\tfn ge(&self, other: &Self) -> bool { for (v, w) in self.bits.iter().zip(other.bits.iter()) { if v != w { return v > w; } } true }",
			"}",
			"impl Ord for Bitset { fn cmp(&self, other: &Self) -> std::cmp::Ordering { self.bits.cmp(&other.bits) } }",
			"impl std::fmt::Debug for Bitset { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, \"{:?}\", self.bits) } }"
		]
	},
	"scc": {
		"prefix": "scc",
		"body": [
			"mod scc {",
			"\t#[allow(dead_code)]",
			"\tfn dfs(now: usize, g: i32, stack: &mut Vec<usize>, group: &mut Vec<i32>, t: &Vec<Vec<usize>>) {",
			"\t\tgroup[now] = g;",
			"\t\tfor to in &t[now] {",
			"\t\t\tif group[*to] < 0 {",
			"\t\t\t\tdfs(*to, g, stack, group, t);",
			"\t\t\t}",
			"\t\t}",
			"\t\tstack.push(now);",
			"\t}",
			"\t#[allow(dead_code)]    ",
			"\tfn dfs2(now: usize, g: i32, group: &Vec<i32>, s: &mut Vec<i32>, r: &Vec<Vec<usize>>) {",
			"\t\ts[now] = g;",
			"\t\tfor to in &r[now] {",
			"\t\t\tif group[now] == group[*to] && s[*to] < 0 {",
			"\t\t\t\tdfs2(*to, g, group, s, r);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\t#[allow(dead_code)]",
			"\t// Return the array of each vertex with ID for each strongly connected component",
			"\tpub fn scc(n: usize, edges: &Vec<(usize, usize)>) -> Vec<i32> {",
			"\t\tlet mut t = vec![vec![]; n];",
			"\t\tlet mut rt = vec![vec![]; n];",
			"\t\tfor (a, b) in edges {",
			"\t\t\tt[*a-1].push(*b-1);",
			"\t\t\trt[*b-1].push(*a-1);",
			"\t\t}",
			"\t\tlet mut group = vec![-1; n];",
			"\t\tlet mut v = vec![];",
			"\t\tlet mut g = 0;",
			"\t\tfor i in 0..n {",
			"\t\t\tif group[i] < 0 {",
			"\t\t\t\tlet mut stack = vec![];",
			"\t\t\t\tdfs(i, g, &mut stack, &mut group, &t);",
			"\t\t\t\tg += 1;",
			"\t\t\t\tv.push(stack);",
			"\t\t\t}",
			"\t\t}",
			"\t\tlet mut g = 0;",
			"\t\tlet mut res = vec![-1; n];",
			"\t\tfor w in v.iter_mut() {",
			"\t\t\twhile !w.is_empty() {",
			"\t\t\t\tlet now = w.pop().unwrap();",
			"\t\t\t\tif res[now] < 0 {",
			"\t\t\t\t\tdfs2(now, g, &group, &mut res, &rt);",
			"\t\t\t\t\tg += 1;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\tres",
			"\t}",
			"}"
		]
	},
	"segtree": {
		"prefix": "segtree",
		"body": [
			"mod segtree {",
			"\t#[allow(dead_code)]",
			"\tpub struct SegmentTree<T>",
			"\twhere T: Clone + Copy + Sized {",
			"\t\tsz: usize,",
			"\t\tdef_val: T,",
			"\t\tupdate_func: fn(T, T) -> T,",
			"\t\ttree: Vec<T>",
			"\t}",
			"\t#[allow(dead_code)]",
			"\timpl<T> SegmentTree<T>",
			"\twhere T: Clone + Copy + Sized {",
			"\t\tpub fn new(size: usize, def_val: T, update_func: fn(T, T) -> T) -> Self {",
			"\t\t\tlet mut sz = 1;",
			"\t\t\twhile sz < size { sz <<= 1; }",
			"\t\t\tlet tree = vec![def_val; sz * 2];",
			"\t\t\tSelf { sz, def_val, update_func, tree }",
			"\t\t}",
			"\t\tpub fn update(&mut self, mut index: usize, val: T) {",
			"\t\t\tindex += self.sz;",
			"\t\t\tself.tree[index] = val;",
			"\t\t\tlet update_func = &self.update_func;",
			"\t\t\twhile index >> 1 > 0 { index >>= 1; self.tree[index] = update_func(self.tree[index*2], self.tree[index*2+1]); }",
			"\t\t}",
			"\t\tfn get_sub(&self, left: usize, right: usize, now: usize, a: usize, b: usize) -> T {",
			"\t\t\tif right <= a || b <= left { return self.def_val; }",
			"\t\t\tif left <= a && b <= right { return self.tree[now]; }",
			"\t\t\tlet update_func = &self.update_func;",
			"\t\t\tlet mut res = self.def_val;",
			"\t\t\tres = update_func(res, self.get_sub(left, right, now*2  , a, (a+b) / 2));",
			"\t\t\tres = update_func(res, self.get_sub(left, right, now*2+1, (a+b) / 2, b));",
			"\t\t\tres",
			"\t\t}",
			"\t\tpub fn get(&self, left: usize, right: usize) -> T { self.get_sub(left, right, 1, 0, self.sz) }",
			"\t}",
			"\t#[allow(dead_code)]",
			"\tpub struct LazySegtree<S, F> {",
			"\t\tn: usize,",
			"\t\tsize: usize,",
			"\t\tlog: usize,",
			"\t\tpub tree: Vec<S>,",
			"\t\tpub lazy: Vec<F>,",
			"\t\top: fn(S, S) -> S,",
			"\t\te: fn() -> S,",
			"\t\tid: fn() -> F,",
			"\t\tmapping: fn(F, S) -> S,",
			"\t\tcomposition: fn(F, F) -> F",
			"\t}",
			"\t#[allow(dead_code)]",
			"\timpl<S, F> LazySegtree<S, F>",
			"\twhere",
			"\t\tS: Copy + Clone + Sized,",
			"\t\tF: Copy + Clone + Sized",
			"\t{",
			"\t\tpub fn new(size: usize, op: fn(S, S) -> S, e: fn() -> S, id: fn() -> F, mapping: fn(F, S) -> S, composition: fn(F, F) -> F) -> Self {",
			"\t\t\tLazySegtree::from_vec(&vec![e(); size], op, e, id, mapping, composition)",
			"\t\t}",
			"\t\tpub fn from_vec(v: &Vec<S>, op: fn(S, S) -> S, e: fn() -> S, id: fn() -> F, mapping: fn(F, S) -> S, composition: fn(F, F) -> F) -> Self {",
			"\t\t\tlet n = v.len();",
			"\t\t\tlet (log, size) = {",
			"\t\t\t\tlet (mut size, mut log) = (1, 0);",
			"\t\t\t\twhile size < n { size <<= 1; log += 1; }",
			"\t\t\t\t(log, size)",
			"\t\t\t};",
			"\t\t\tlet mut tree = vec![e(); size * 2];",
			"\t\t\tlet lazy = vec![id(); size * 2];",
			"\t\t\tfor (i, w) in v.iter().enumerate() { tree[size + i] = *w; }",
			"\t\t\tfor i in (0..size).skip(1).rev() { tree[i] = op(tree[i*2], tree[i*2 + 1]); }",
			"\t\t\tSelf { n, size, log, tree, lazy, op, e, id, mapping, composition }",
			"\t\t}",
			"\t\tpub fn set(&mut self, idx: usize, val: S) {",
			"\t\t\tassert!(idx < self.n);",
			"\t\t\tlet idx = idx + self.size;",
			"\t\t\tfor i in (0..self.log+1).skip(1).rev() { self.push(idx >> i); }",
			"\t\t\tself.tree[idx] = val;",
			"\t\t\tfor i in 1..=self.log { self.update(idx >> i); }",
			"\t\t}",
			"\t\t// Get the value of a single point whose index is idx.",
			"\t\tpub fn get(&mut self, idx: usize) -> S {",
			"\t\t\tassert!(idx < self.n);",
			"\t\t\tlet idx = idx + self.size;",
			"\t\t\tfor i in (0..self.log+1).skip(1).rev() { self.push(idx >> i); }",
			"\t\t\tself.tree[idx]",
			"\t\t}",
			"\t\t// Get the result of applying the operation to the interval [l, r).",
			"\t\tpub fn prod(&mut self, l: usize, r: usize) -> S {",
			"\t\t\tassert!(l <= r && r <= self.n);",
			"\t\t\tif l == r { return self.e(); }",
			"\t\t\tlet (mut l, mut r) = (l + self.size, r + self.size);",
			"\t\t\tfor i in (0..self.log+1).skip(1).rev() {",
			"\t\t\t\tif ((l >> i) << i) != l { self.push(l >> i); }",
			"\t\t\t\tif ((r >> i) << i) != r { self.push(r >> i); }",
			"\t\t\t}",
			"\t\t\tlet (mut sml, mut smr) = (self.e(), self.e());",
			"\t\t\twhile l < r {",
			"\t\t\t\tif (l & 1) != 0 { sml = self.op(sml, self.tree[l]); l += 1; }",
			"\t\t\t\tif (r & 1) != 0 { r -= 1; smr = self.op(self.tree[r], smr); }",
			"\t\t\t\tl >>= 1; r >>= 1;",
			"\t\t\t}",
			"\t\t\tself.op(sml, smr)",
			"\t\t}",
			"\t\tpub fn all_prod(&self) -> S { self.tree[1] }",
			"\t\t// Apply val to a point whose index is idx.",
			"\t\tpub fn apply(&mut self, idx: usize, val: F) {",
			"\t\t\tassert!(idx < self.n);",
			"\t\t\tlet idx = idx + self.size;",
			"\t\t\tfor i in (0..self.log+1).skip(1).rev() { self.push(idx >> i); }",
			"\t\t\tself.tree[idx] = self.mapping(val, self.tree[idx]);",
			"\t\t\tfor i in 1..=self.log { self.update(idx >> i); }",
			"\t\t}",
			"\t\t// Apply val to the interval [l, r).",
			"\t\tpub fn apply_range(&mut self, l: usize, r: usize, val: F) {",
			"\t\t\tassert!(l <= r && r <= self.n);",
			"\t\t\tif l == r { return; }",
			"\t\t\tlet (l, r) = (l + self.size, r + self.size);",
			"\t\t\tfor i in (0..self.log+1).skip(1).rev() {",
			"\t\t\t\tif ((l >> i) << i) != l { self.push(l >> i); }",
			"\t\t\t\tif ((r >> i) << i) != r { self.push((r-1) >> i); }",
			"\t\t\t}",
			"\t\t\tlet (mut a, mut b) = (l, r);",
			"\t\t\twhile a < b {",
			"\t\t\t\tif (a & 1) != 0 { self.all_apply(a, val); a += 1; }",
			"\t\t\t\tif (b & 1) != 0 { b -= 1; self.all_apply(b, val); }",
			"\t\t\t\ta >>= 1; b >>= 1;",
			"\t\t\t}",
			"\t\t\tfor i in 1..=self.log {",
			"\t\t\t\tif ((l >> i) << i) != l { self.update(l >> i); }",
			"\t\t\t\tif ((r >> i) << i) != r { self.update((r-1) >> i); }",
			"\t\t\t}",
			"\t\t}",
			"\t\tfn update(&mut self, idx: usize) { self.tree[idx] = self.op(self.tree[idx*2], self.tree[idx*2+1]); }",
			"\t\tfn all_apply(&mut self, idx: usize, val: F) {",
			"\t\t\tlet mapping = self.mapping;",
			"\t\t\tself.tree[idx] = mapping(val, self.tree[idx]);",
			"\t\t\tif idx < self.size { self.lazy[idx] = self.composition(val, self.lazy[idx]); }",
			"\t\t}",
			"\t\tfn push(&mut self, idx: usize) {",
			"\t\t\tself.all_apply(idx*2, self.lazy[idx]);",
			"\t\t\tself.all_apply(idx*2 + 1, self.lazy[idx]);",
			"\t\t\tself.lazy[idx] = self.id();",
			"\t\t}",
			"\t\tfn op(&self, l: S, r: S) -> S { let op = self.op; op(l, r) }",
			"\t\tfn e(&self) -> S { let e = self.e; e() }",
			"\t\tfn id(&self) -> F { let id = self.id; id() }",
			"\t\tfn mapping(&self, f: F, x: S) -> S { let mapping = self.mapping; mapping(f, x) }",
			"\t\tfn composition(&self, f: F, g: F) -> F { let composition = self.composition; composition(f, g) }",
			"\t}",
			"\timpl<S, F> std::fmt::Debug for LazySegtree<S, F>",
			"\twhere",
			"\t\tS: Copy + Clone + std::fmt::Debug,",
			"\t\tF: Copy + Clone + std::fmt::Debug",
			"\t{",
			"\t\tfn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
			"\t\t\tlet (mut tree, mut lazy, mut l, mut r) = (vec![], vec![], 1, 2);",
			"\t\t\twhile r < self.tree.len() {",
			"\t\t\t\tlet (mut nd, mut nlz) = (vec![], vec![]);",
			"\t\t\t\tfor i in l..r { nd.push(self.tree[i]); nlz.push(self.lazy[i]); }",
			"\t\t\t\ttree.push(nd); lazy.push(nlz);",
			"\t\t\t\tl <<= 1; r <<= 1;",
			"\t\t\t}",
			"\t\t\twrite!(f, \"tree: {:?}\\nlz: {:?}\", tree, lazy)",
			"\t\t}",
			"\t}",
			"\t#[allow(dead_code)]",
			"\tpub fn range_add_range_sum_query(size: usize) -> LazySegtree<(i64, i64), i64> {",
			"\t\tLazySegtree::from_vec(",
			"\t\t\t&vec![(0i64, 1i64); size],",
			"\t\t\t|l, r| (l.0+r.0, l.1+r.1),",
			"\t\t\t|| (0, 0),",
			"\t\t\t|| 0i64,",
			"\t\t\t|f, x| (x.0+f*x.1, x.1),",
			"\t\t\t|f, g| f + g)",
			"\t}",
			"\t#[allow(dead_code)]",
			"\tpub fn range_add_range_maximum_query(size: usize) -> LazySegtree<i64, i64> {",
			"\t\tLazySegtree::from_vec(",
			"\t\t\t&vec![0i64; size],",
			"\t\t\t|l, r| std::cmp::max(l, r),",
			"\t\t\t|| -9223372036854775808i64,",
			"\t\t\t|| 0i64,",
			"\t\t\t|f, x| f + x,",
			"\t\t\t|f, g| f + g)",
			"\t}",
			"\t#[allow(dead_code)]",
			"\tpub fn range_add_range_minimum_query(size: usize) -> LazySegtree<i64, i64> {",
			"\t\tLazySegtree::from_vec(",
			"\t\t\t&vec![0i64; size],",
			"\t\t\t|l, r| std::cmp::min(l, r),",
			"\t\t\t|| 0x7FFFFFFFFFFFFFFFi64,",
			"\t\t\t|| 0i64,",
			"\t\t\t|f, x| f + x,",
			"\t\t\t|f, g| f + g)",
			"\t}",
			"\t// Range Add Range Maximum Query: F: i64, S: i64, from_vec(&vec![0i64; size], |l, r| std::cmp::max(l, r), || -111222333444555666i64, || 0i64, |f, x| f + x, |f, g| f + g);",
			"\t// Range Add Range Minimum Query: F: i64, S: i64, from_vec(&vec![0i64; size], |l, r| std::cmp::min(l, r), || 111222333444555666i64, || 0i64, |f, x| f + x, |f, g| f + g);",
			"\t// Range Add Range Sum Query: F: i64, S: (i64, i64), from_vec(&vec![(0i64, 1i64); size], |l, r| (l.0+r.0, l.1+r.1), || (0, 0), || 0i64, |f, x| (x.0+f*x.1, x.1), |f, g| f + g);",
			"}",
			"#[allow(unused_imports)]",
			"use segtree::SegmentTree;",
			"#[allow(unused_imports)]",
			"use segtree::LazySegtree;"
		]
	}
}