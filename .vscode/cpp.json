{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"UnionFind":{
		"prefix": "UnionFind",
		"body": [
			"struct UnionFind {",
			"\tvector<int> par;",
			"\tUnionFind(int n) : par(vector<int>(n, -1)) {}",
			"\tint root(int x) { return par[x] < 0 ? x : par[x] = root(par[x]); }",
			"\tbool isSame(int x, int y) { return root(x) == root(y); }",
			"\tint size(int x) { return -par[root(x)]; }",
			"\tbool merge(int x, int y) {",
			"\t\tint rx = root(x), ry = root(y);",
			"\t\tif(rx == ry) return false;",
			"\t\tif(par[rx] > par[ry]) swap(rx, ry);",
			"\t\tpar[rx] += par[ry];",
			"\t\tpar[ry] = rx;",
			"\t\treturn true;",
			"\t}",
			"};"
		]
	},
	"chmax":{
		"prefix": "chmax",
		"body": "template<class T, class U> void chmax(T &a, U b){if(a < b) a = b;}"
	},
	"chmin":{
		"prefix": "chmin",
		"body": "template<class T ,class U> void chmin(T &a, U b){if(b < a) a = b;}"
	},
	"modPow":{
		"prefix": "modPow",
		"body": [
			"int modPow(long long a, long long n, long long p) {",
				"\tif (n == 0) return 1;",
				"\ta %= p;",
				"\tif (n == 1) return a;",
				"\tif (n % 2 == 1) return (a * modPow(a, n - 1, p)) % p;",
				"\tlong long t = modPow(a, n / 2, p);",
				"\treturn (t * t) % p;",
			"}"
		]	
	},
	"digits":{
		"prefix": "digits",
		"body": [
			"ll digits(ll n){",
			"\tint exp=0;",
			"\twhile(n>0){",
			"\t\tn/=10;",
			"\t\texp++;",
			"\t}",
			"\treturn exp;",
			"}"
		]
	},
	"extGcd": {
		"prefix": "extGcd",
		"body": "ll extGCD(ll a, ll b, ll &p, ll &q) {if(b == 0) {p = 1;q = 0;return a;}ll d = extGCD(b, a%b, q, p);q -= a/b * p;return d;}"
	},
	"ChineseRemainerTheorem": {
		"prefix": "ChineseRemainerTheorem",
		"body": [
			"\/\/ d : gcd(a, b)",
			"ll extGCD(ll a, ll b, ll &p, ll &q) {",
			"\tif(b == 0) {",
			"\t\tp = 1; q = 0;",
			"\t\treturn a;",
			"\t}",
			"\tll d = extGCD(b, a%b, q, p);",
			"\tq -= a/b * p;",
			"\treturn d;",
			"}",
			"\/\/ Return the value of b1 for mod m1 and b2 for mod m2 when m1 and m2 are coprime",
			"\/\/ If the return value are (r, m), x = r (mod m), m = lcm(m1, m2). ",
			"\/\/ If the return value are (0, -1), there is no solution.",
			"pll crt(ll b1, ll m1, ll b2, ll m2) {",
			"\tll p, q;",
			"\tll d = extGCD(m1, m2, p, q);",
			"\tif((b2 - b1) % d != 0) return make_pair(0, -1);",
			"\tll m = m1 * (m2/d);",
			"\tll tmp = (b2 - b1) \/ d * p % (m2/d);",
			"\tauto mod = [](ll a, ll m) { return (a%m + m) % m; };",
			"\tll r = mod(b1 + m1 * tmp, m);",
			"\treturn make_pair(r, m);",
			"}"
		]
	},
	"modint": {
		"prefix": "mint",
		"body": [
			"struct mint {",
			"\tll val;",
			"\tconstexpr mint(ll val=0) : val((val%MOD + MOD) % MOD) {}",
			"\tconstexpr mint(const mint &m) : val(m.val) {}",
			"\tconstexpr mint operator-() const {return mint(-val);}",
			"\tconstexpr mint operator+(const mint &m) const noexcept {return mint(*this) += m;}",
			"\tconstexpr mint operator-(const mint &m) const noexcept {return mint(*this) -= m;}",
			"\tconstexpr mint operator*(const mint &m) const noexcept {return mint(*this) *= m;}",
			"\tconstexpr mint operator/(const mint &m) const noexcept {return mint(*this) /= m;}",
			"\tconstexpr mint &operator+=(const mint &a) noexcept {if((val += a.val) >= MOD) val -= MOD; return *this;}",
			"\tconstexpr mint &operator-=(const mint &a) noexcept {if((val -= a.val) < 0) val += MOD; return *this;}",
			"\tconstexpr mint &operator*=(const mint &a) noexcept {val = val * a.val % MOD; return *this;}",
			"\tconstexpr mint &operator/=(const mint m) noexcept {return *this *= m.inv();}",
			"\tconstexpr mint pow(ll t) const {if(!t) return 1; mint a = pow(t >> 1); return (t & 1) ? a * a * (*this) : a * a;}",
			"\tconstexpr mint inv() const {return pow(MOD-2);}",
			"\tbool operator==(const mint &m) {return val == m.val;}",
			"\tbool operator<(const mint &m) {return val < m.val;}",
			"\tbool operator>(const mint &m) {return val > m.val;}",
			"\tbool operator<=(const mint &m) {return val <= m.val;}",
			"\tbool operator>=(const mint &m) {return val >= m.val;}",
			"\tbool operator!=(const mint &m) {return val != m.val;}",
			"\tfriend ostream &operator<<(ostream &os, const mint &m) {os << m.val; return os;}",
			"\tfriend istream &operator>>(istream & is, mint &m) {is >> m.val; return is;}",
			"};",
			"struct combination {",
			"\tvector<mint> fact, ifact;",
			"\tcombination(int n) : fact(n+1), ifact(n+1) {",
			"\t\tassert(n < MOD);",
			"\t\tfact[0] = 1LL; for(ll i = 1; i <= n; i++) fact[i] = fact[i-1] * i;",
			"\t\tifact[n] = fact[n].inv(); for(ll i = n; i >= 1; i--) ifact[i-1] = ifact[i] * i;",
			"\t}",
			"\t// {combination c(n); mint ans = c(n, k);} => (ans == nCk)",
			"\tmint operator()(int n, int k) { return (k < 0 || k > n) ? 0 : fact[n] * ifact[k] * ifact[n-k]; }",
			"};"
		]
	},
	"Date":{
		"prefix": "Date",
		"body": [
			"class Date {",
			"\tint year, month, day;",
			"\tvoid subMonth(int m) { month -= m; while(month < 0) { year--; month += 12; } }",
			"\tint endOfManth(int m=-1) {",
			"\t\tif(m < 1) m = month+1;",
			"\t\tif(m == 2) return isLeap() ? 29 : 28;",
			"\t\telse if(m == 4 || m == 6 || m == 9 || m == 11) return 30;",
			"\t\telse return 31;",
			"\t}",
			"public:",
			"\tDate(int year, int month, int day) : year(year-1), month(month-1), day(day-1) {}",
			"\tDate(string year, string month, string day) : year(stoi(year)), month(stoi(year)), day(stoi(day)) {}",
			"\tDate(const Date &date) : year(date.year), month(date.month), day(date.day) {}",
			"\tint yearVal() { return year+1; }",
			"\tint monthVal() { return month+1; }",
			"\tint dayVal() { return day+1; }",
			"\tstring yearStr() { return to_string(year+1); }",
			"\tstring monthStr() { return to_string(month+1); }",
			"\tstring dayStr() { return to_string(day+1); }",
			"\tbool isLeap(int y=-1) { if(y == -1) y = year+1; return y % 4 ? false : y % 100 ? true : y % 400 ? false : true; }",
			"\tvoid addYear(int y) { year += y; }",
			"\tvoid addMonth(int m) { month += m; if(month > 11) { addYear(1); month -= 12; } }",
			"\tvoid addDay(int d) { day += d; int mx = endOfManth(month+1); while(day+1 > mx) { day -= mx; addMonth(1); mx = endOfManth(month+1); } }",
			"\tvoid subDay(int d) { day -= d; while(day < 0) { subMonth(1); day += endOfManth(month+1); } }",
			"\tDate &operator++() { addDay(1); return *this; }",
			"\tDate &operator--() { subDay(1); return *this; }",
			"};"
		]
	},
	"TwoDimensionalCumulativeSum": {
		"prefix": "TwoDimCumulativeSum",
		"body": [
			"class TwoDimCumulativeSum {",
			"\tint h, w;",
			"\tvector<vector<int>> sum;",
			"public:",
			"\tTwoDimCumulativeSum(vector<vector<int>> a) {",
			"\t\th = a.size();",
			"\t\tw = a[0].size();",
			"\t\tsum.assign(h+1, vector<int>(w+1));",
			"\t\tfor(int i = 1; i < h+1; i++) for(int j = 1; j < w+1; j++) sum[i][j] = a[i-1][j-1] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1];",
			"\t}",
			"\tint rangeSum(int top, int btm, int lft, int rht) {",
			"\t\treturn sum[btm][rht] - sum[top][rht] - sum[btm][lft] + sum[top][lft];",
			"\t}",
			"};"
		]
	},
	"SegmentTree": {
		"prefix": "SegmentTree",
		"body": [
			"template<class T>",
			"struct SegmentTree {",
			" private:",
			"  using update_func_t = function<T(T element, T val)>;",
			"  int sz;",
			"  T def_val;",
			"  vector<T> tree;",
			"  update_func_t update_func;",
			" public:",
			"  SegmentTree(int size, T default_val, update_func_t update_func) : def_val(default_val), update_func(update_func) {",
			"    sz = 1; while(sz < size) sz <<= 1;",
			"    tree.assign(sz*2, def_val);",
			"  }",
			"  void update(int idx, T val) {",
			"    idx += sz;",
			"    tree[idx] = val;",
			"    while(idx >> 1) {",
			"      idx >>= 1;",
			"      tree[idx] = update_func(tree[idx*2], tree[idx*2+1]);",
			"    }",
			"  }",
			"  T get(int l, int r) {",
			"    return do_get(l, r, 1, 0, sz);",
			"  }",
			" private:",
			"  T do_get(int l, int r, int now, int a, int b) {",
			"    if(r <= a || b <= l) return def_val;",
			"    if(l <= a && b <= r) return tree[now];",
			"    T res = def_val;",
			"    res = update_func(res, do_get(l, r, now*2,   a, (a+b)/2));",
			"    res = update_func(res, do_get(l, r, now*2+1, (a+b)/2, b));",
			"    return res;",
			"  }",
			"};",
			"struct RangeMinimumQuery : SegmentTree<ll> { RangeMinimumQuery(int size) : SegmentTree(size, INF, [](ll lhs, ll rhs) { return min(lhs, rhs); }) {} };",
			"struct RangeMaximumQuery : SegmentTree<ll> { RangeMaximumQuery(int size) : SegmentTree(size, -INF, [](ll lhs, ll rhs) { return max(lhs, rhs); }) {} };",
			"struct RangeSumQuery : SegmentTree<ll> { RangeSumQuery(int size) : SegmentTree(size, 0, [](ll lhs, ll rhs) { return lhs + rhs; }) {} };",
			"struct RMinRSumQuery : SegmentTree<pll> { RMinRSumQuery(int size) : SegmentTree(size, make_pair(0LL, 0LL), [](pll lhs, pll rhs) { return make_pair(min(lhs.first, lhs.second+rhs.first), lhs.second+rhs.second); }) {} };"
		]
	},
	"LazySegmentTree": {
		"prefix": "LazySegmentTree",
		"body": [
			"struct LazySegmentTree {",
			" private:",
			"\tint n;",
			"\tvector<ll> node, lazy;",
			" public:",
			"\tvoid init(int sz) {",
			"\t\tn = 1;",
			"\t\twhile(n < sz) n *= 2;",
			"\t\tnode.resize(2*n-1); lazy.resize(2*n-1);",
			"\t}",
			"\tLazySegmentTree(int sz) {",
			"\t init(sz);",
			"\t}",
			"\tLazySegmentTree(vector<ll> &v) {",
			"\t\tint sz = v.size();",
			"\t\tinit(sz);",
			"\t\tfor(int i = 0; i < sz; i++) node[i+n-1] = v[i];",
			"\t\t\/\/ RSQ initialize",
			"\t\tfor(int i = n-2; i >= 0; i--) node[i] = node[i*2+1] + node[i*2+2];",
			"\t\t\/\/ RMQ initialize",
			"\t\t\/\/ for(int i = n-2; i >= 0; i--) node[i] = max(node[i*2+1], node[i*2+2]);",
			"\t}",
			"\tvoid eval(int now, int l, int r) {",
			"\t\tif(lazy[now] != 0) {",
			"\t\t\tnode[now] += lazy[now];",
			"\t\t\tif(r - l > 1) {",
			"\t\t\t\tlazy[2*now+1] += lazy[now] / 2;",
			"\t\t\t\tlazy[2*now+2] += lazy[now] / 2;",
			"\t\t\t}",
			"\t\t\tlazy[now] = 0;",
			"\t\t}",
			"\t}",
			"\tvoid evalMax(int now, int l, int r) {",
			"\t\tif(lazy[now] > 0) {",
			"\t\t\tnode[now] = max(node[now], lazy[now]);",
			"\t\t\tif(r - l > 1) {",
			"\t\t\t\tlazy[2*now+1] = max(lazy[now], lazy[2*now+1]);",
			"\t\t\t\tlazy[2*now+2] = max(lazy[now], lazy[2*now+2]);",
			"\t\t\t}",
			"\t\t\tlazy[now] = 0;",
			"\t\t}",
			"\t}",
			"\tvoid add(int a, int b, ll x, int k=0, int l=0, int r=-1) {",
			"\t\tif(r < 0) r = n;",
			"\t\teval(k, l, r);",
			"\t\tif(b <= l || r <= a) return;",
			"\t\tif(a <= l && r <= b) {",
			"\t\t\tlazy[k] += (r-l) * x;",
			"\t\t\teval(k, l, r);",
			"\t\t} else {",
			"\t\t\tadd(a, b, x, 2*k+1, l, (l+r)/2);",
			"\t\t\tadd(a, b, x, 2*k+2, (l+r)/2, r);",
			"\t\t\tnode[k] = node[2*k+1] + node[2*k+2];",
			"\t\t}",
			"\t}",
			"\tll getSum(int a, int b, int k=0, int l=0, int r=-1) {",
			"\t\tif(r < 0) r = n;",
			"\t\tif(b <= l || r <= a) return 0;",
			"\t\teval(k, l, r);",
			"\t\tif(a <= l && r <= b) return node[k];",
			"\t\tll res = 0;",
			"\t\tres += getSum(a, b, 2*k+1, l, (l+r)/2);",
			"\t\tres += getSum(a, b, 2*k+2, (l+r)/2, r);",
			"\t\treturn res;",
			"\t}",
			"\tvoid updateMax(int a, int b, ll x, int now=0, int l=0, int r=-1) {",
			"\t\tif(r < 0) r = n;",
			"\t\tevalMax(now, l, r);",
			"\t\tif(b <= l || r <= a) return;",
			"\t\tif(a <= l && r <= b) {",
			"\t\t\tlazy[now] = max(lazy[now], x);",
			"\t\t\tevalMax(now, l, r);",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tupdateMax(a, b, x, 2*now+1, l, (l+r)/2);",
			"\t\tupdateMax(a, b, x, 2*now+2, (l+r)/2, r);",
			"\t\tnode[now] = max(node[2*now+1], node[2*now+2]);",
			"\t}",
			"\tll getMax(int a, int b, int now=0, int l=0, int r=-1) {",
			"\t\tif(r < 0) r = n;",
			"\t\tif(b <= l || r <= a) return 0;",
			"\t\tevalMax(now, l, r);",
			"\t\tif(a <= l && r <= b) return node[now];",
			"\t\tll res = 0;",
			"\t\tres = max(res, getMax(a, b, 2*now+1, l, (l+r)/2));",
			"\t\tres = max(res, getMax(a, b, 2*now+2, (l+r)/2, r));",
			"\t\treturn res;",
			"\t}",
			"};"
		]
	},
	"Complex": {
		"prefix": "Complex",
		"body": [
			"template <typename T>",
			"class Complex {",
			"\tT r, i;",
			"\tconst T eps = 1e-6;",
			"public:",
			"\tComplex() : r(0), i(0) {}",
			"\tComplex(T real, T imag) : r(real), i(imag) {}",
			"\tComplex(Complex& c) : r(c.real()), i(c.imag()) {}",
			"\tComplex(const Complex& c) : r(c.real()), i(c.imag()) {}",
			"\t~Complex() = default;",
			"\tT real() { return r; }",
			"\tT imag() { return i; }",
			"\tT real() const { return r; }",
			"\tT imag() const { return i; }",
			"\tconstexpr Complex<T>& operator=(const T& rhs) { r = rhs; i = 0; return *this; }",
			"\tconstexpr Complex<T>& operator=(const Complex<T>& rhs) { r = rhs.real(); i = rhs.imag(); return *this; }",
			"\ttemplate<typename X>",
			"\tconstexpr Complex<T>& operator=(const Complex<X>& rhs) { r = rhs.real(); i = rhs.imag(); return *this; }",
			"\tconstexpr Complex<T>& operator+=(const T& rhs) { r += rhs; return *this; }",
			"\ttemplate<typename X>",
			"\tconstexpr Complex<T>& operator+=(const Complex<X>& rhs) { r += rhs.real(); i += rhs.imag(); return *this; }",
			"\tconstexpr Complex<T>& operator-=(const T& rhs) { r -= rhs; return *this; }",
			"\ttemplate<typename X>",
			"\tconstexpr Complex<T>& operator-=(const Complex<X>& rhs) { r -= rhs.real(); i -= rhs.imag(); return *this; }",
			"\tconstexpr Complex<T>& operator*=(const T& rhs) { r *= rhs; i *= rhs; return *this; }",
			"\ttemplate<typename X>",
			"\tconstexpr Complex<T>& operator*=(const Complex<X>& rhs) {",
			"\t\tT nr = r*rhs.real() - i*rhs.imag();",
			"\t\tT ni = i*rhs.real() + r*rhs.imag();",
			"\t\tr = nr, i = ni;",
			"\t\treturn *this;",
			"\t}",
			"\tconstexpr Complex<T>& operator/=(const T& rhs) { r /= rhs; i /= rhs; return *this; }",
			"\ttemplate<typename X>",
			"\tconstexpr Complex<T>& operator/=(const Complex<X>& rhs) {",
			"\t\tT rr = rhs.real(), ri = rhs.imag();",
			"\t\tT nr = (r*rr + i*ri) / (rr*rr + ri*ri);",
			"\t\tT ni = (i*rr - r*ri) / (rr*rr + ri*ri);",
			"\t\tr = nr, i = ni;",
			"\t\treturn *this;",
			"\t}",
			"\tconstexpr Complex<T> operator+() { return *this; }",
			"\tconstexpr Complex<T> operator-() { return Complex<T>(-r, -i); }",
			"\tconstexpr Complex<T> operator+(const Complex<T>& rhs) { return Complex<T>(*this) += rhs; }",
			"\tconstexpr Complex<T> operator+(const T& rhs) { return Complex<T>(*this) += rhs; }",
			"\tconstexpr Complex<T> operator-(const Complex<T>& rhs) { return Complex<T>(*this) -= rhs; }",
			"\tconstexpr Complex<T> operator-(const T& rhs) { return Complex<T>(*this) -= rhs; }",
			"\tconstexpr Complex<T> operator*(const Complex<T>& rhs) { return Complex<T>(*this) *= rhs; }",
			"\tconstexpr Complex<T> operator*(const T& rhs) { return Complex<T>(*this) *= rhs; }",
			"\tconstexpr Complex<T> operator/(const Complex<T>& rhs) { return Complex<T>(*this) /= rhs; }",
			"\tconstexpr Complex<T> operator/(const T& rhs) { return Complex<T>(*this) /= rhs; }",
			"\tconstexpr bool operator==(Complex<T>& rhs) { return (std::abs(r-rhs.real()) <= eps) && (std::abs(i-rhs.imag()) <= eps); }",
			"\tconstexpr bool operator!=(Complex<T>& rhs) { return (std::abs(r-rhs.real()) > eps) || (std::abs(i-rhs.imag()) > eps); }",
			"\tconstexpr bool operator<(Complex<T>& rhs) { return (std::abs(r-rhs.real()) <= eps) ? i < rhs.imag() : r < rhs.real(); }",
			"\tconstexpr bool operator>(Complex<T>& rhs) { return (std::abs(r-rhs.real()) <= eps) ? i > rhs.imag() : r > rhs.real(); }",
			"\tconstexpr bool operator<=(Complex<T>& rhs) { return (*this == rhs) || (*this < rhs); }",
			"\tconstexpr bool operator>=(Complex<T>& rhs) { return (*this == rhs) || (*this > rhs); }",
			"\tconstexpr bool operator==(const Complex<T>& rhs) const { return (std::abs(r-rhs.real()) <= eps) && (std::abs(i-rhs.imag()) <= eps); }",
			"\tconstexpr bool operator!=(const Complex<T>& rhs) const { return (std::abs(r-rhs.real()) > eps) || (std::abs(i-rhs.imag()) > eps); }",
			"\tconstexpr bool operator<(const Complex<T>& rhs) const { return (std::abs(r-rhs.real()) <= eps ? i < rhs.imag() : r < rhs.real()); }",
			"\tconstexpr bool operator>(const Complex<T>& rhs) const { return (std::abs(r-rhs.real()) <= eps ? i > rhs.imag() : r > rhs.real()); }",
			"\tconstexpr bool operator<=(const Complex<T>& rhs) const { return (*this == rhs) || (*this < rhs); }",
			"\tconstexpr bool operator>=(const Complex<T>& rhs) const { return (*this == rhs) || (*this > rhs); }",
			"\tT norm() { return r*r + i*i; }",
			"\tT abs() { return sqrtl(this->norm()); }",
			"\tT arg() { return atan2(i, r); }",
			"\tconstexpr Complex<T> conj() { return Complex<T>(r, -i); }",
			"\tComplex<T> polar(const T& rho, const T& theta = 0) { return Complex<T>(rho*cos(theta), rho*sin(theta)); }",
			"\tfriend ostream &operator<<(ostream &os, const Complex<T> &c) {os << \"(\" << c.real() << \", \" << c.imag() << \")\"; return os;}",
			"};"
		]
	},
	"Z-algorithm": {
		"prefix": "Zalgorithm",
		"body": [
			"vector<int> Zalgo(string& s) {",
			"\tint n = s.length();",
			"\tvector<int> z(n);",
			"\tint from = -1, to = -1;",
			"\tfor(int i=1;i<n;i++) {",
			"\t\tint &j = z[i];",
			"\t\tif(from != -1) j = min(z[i-from], max(0, to-i));",
			"\t\twhile(i+j < n && s[j] == s[i+j]) j++;",
			"\t\tif(to < i+j) {",
			"\t\t\tfrom = i;",
			"\t\t\tto = i+j;",
			"\t\t}",
			"\t\tz[0] = n;",
			"\t}",
			"\treturn z;",
			"}"
		]
	},
	"FenwickTree": {
		"prefix": "FenwickTree",
		"body": [
			"template<class T>",
			"class FenwickTree {",
			"\tvector<T> t;",
			"\tint sz;",
			"public: ",
			"\tFenwickTree(int n) : sz(n+1), t(vector<T>(n+1, 0)) {}",
			"\t// fix the 0-based array to the 1-based array",
			"\tFenwickTree(vector<T> &s) : sz(s.size() + 1) {",
			"\t\tt.assign(sz, 0);",
			"\t\tfor(int i=0;i<s.size();i++) add(i, s[i]);",
			"\t}",
			"\t// add(idx, val) => add val to idx th element",
			"\t// idx : 0-based index",
			"\tvoid add(int idx, T val) {",
			"\t\tidx++;",
			"\t\twhile(idx < sz) {",
			"\t\t\tt[idx] += val;",
			"\t\t\tidx += idx & -idx;",
			"\t\t}",
			"\t}",
			"\t// getSum(l, r) => get the sum of [l, r)",
			"\t// l, r : 0-based index",
			"\tT getSum(int l, int r) {",
			"\t\t// need not fix l and r to 1-based index",
			"\t\t// because subGetSum() needs a 0-based index argument.",
			"\t\treturn subGetSum(r) - subGetSum(l);",
			"\t}",
			"\t// lower_bound(val) => return 0-based index",
			"\tint lower_bound(T val) {",
			"\t\tif(val <= 0) return 0;",
			"\t\tint now = 0;",
			"\t\tint n = 1;",
			"\t\twhile(n<<1 <= sz) n <<= 1;",
			"\t\tfor(int i=n;i>0;i>>=1) {",
			"\t\t\tif(now+i < sz && t[now+i] < val) {",
			"\t\t\t\tval -= t[now+i];",
			"\t\t\t\tnow += i;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn now;",
			"\t}",
			"\t// upper_bound(val) => return 0-based index",
			"\tint upper_bound(T val) {",
			"\t\tif(val <= 0) return 0;",
			"\t\tint now = 0;",
			"\t\tint n = 1;",
			"\t\twhile(n<<1 <= sz) n <<= 1;",
			"\t\tfor(int i=n;i>0;i>>=1) {",
			"\t\t\tif(now+i < sz && t[now+i] <= val) {",
			"\t\t\t\tval -= t[now+i];",
			"\t\t\t\tnow += i;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn now;",
			"\t}",
			"private:",
			"\t// subGetSum(r) => get the sum of [0, r)",
			"\t// r : 0-based index",
			"\tT subGetSum(int r) {",
			"\t\tif(r < 0) return 0;",
			"\t\tif(r >= sz) r = sz-1;",
			"\t\tT res = 0;",
			"\t\twhile(r > 0) {",
			"\t\t\tres += t[r];",
			"\t\t\tr -= r & -r;",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"};"
		]
	},
	"heap": {
		"prefix": "heap",
		"body": [
			"template<class T>",
			"struct heap {",
			"\tpriority_queue<T, vector<T>, greater<T>> pq;",
			"\theap() : pq() {}",
			"\theap(priority_queue<T, vector<T>, greater<T>> pq) : pq(pq) {}",
			"\tvoid push(T c) { pq.push(c); }",
			"\tT top() { return pq.top(); }",
			"\tvoid pop() { pq.pop(); }",
			"\tbool empty() { return pq.empty(); }",
			"\tint size() { return pq.size(); }",
			"\tvoid swap(heap<T> nt) { pq.swap(nt.pq); }",
			"};"
		]
	},
	"Edge": {
		"prefix": "Edge",
		"body": [
			"struct Edge {",
			"\tint to;",
			"\tlong long weight;",
			"\tEdge() : to(0), weight(0) {}",
			"\tEdge(int to, long long weight) : to(to), weight(weight) {}",
			"\tEdge(const Edge& e) : to(e.to), weight(e.weight) {}",
			"\tbool operator>(const Edge &e) const { return weight > e.weight; }",
			"\tbool operator<(const Edge &e) const { return weight < e.weight; }",
			"\tbool operator==(const Edge &e) const { return weight == e.weight; }",
			"\tbool operator<=(const Edge &e) const { return weight <= e.weight; }",
			"\tbool operator>=(const Edge &e) const { return weight >= e.weight; }",
			"};"
		]
	},
	"weightedGraph": {
		"prefix": "weightedGraph",
		"body": [
			"struct Edge {",
			"\tint to;",
			"\tlong long weight;",
			"\tEdge() : to(0), weight(0) {}",
			"\tEdge(int to, long long weight) : to(to), weight(weight) {}",
			"\tEdge(const Edge& e) : to(e.to), weight(e.weight) {}",
			"\tbool operator>(const Edge &e) const { return weight > e.weight; }",
			"\tbool operator<(const Edge &e) const { return weight < e.weight; }",
			"\tbool operator==(const Edge &e) const { return weight == e.weight; }",
			"\tbool operator<=(const Edge &e) const { return weight <= e.weight; }",
			"\tbool operator>=(const Edge &e) const { return weight >= e.weight; }",
			"};",
			"using weightedGraph = vector<vector<Edge>>;"
		]
	},
	"Matrix": {
		"prefix": "Matrix",
		"body": [
			"template<typename T>",
			"struct Matrix {",
			"\tint row;",
			"\tint column;",
			"\tvector<vector<T>> t;",
			"\tMatrix() : row{0}, column{0}, t{vector<vector<T>>(0, vector<T>(0, 0))} {}",
			"\tMatrix(int r, int c) : row{r}, column{c}, t{vector<vector<T>>(r, vector<T>(c, 0))} {}",
			"\tMatrix(vector<vector<T>> v) : row{(int)v.size()}, column{(int)v[0].size()}, t{v} {}",
			"\tMatrix(const Matrix &m) : row{m.row}, column{m.column}, t{m.t} {}",
			"\tconstexpr Matrix operator+(const Matrix &m) {",
			"\t\tassert(row == m.row && column == m.column);",
			"\t\tMatrix res(*this);",
			"\t\tfor(int i=0;i<row;i++) for(int j=0;j<column;j++) res[i][j] = t[i][j] + m[i][j];",
			"\t\treturn res;",
			"\t}",
			"\tconstexpr Matrix operator-(const Matrix &m) {",
			"\t\tassert(row == m.row && column == m.column);",
			"\t\tMatrix res(*this);",
			"\t\tfor(int i=0;i<row;i++) for(int j=0;j<column;j++) res[i][j] = t[i][j] - m[i][j];",
			"\t\treturn res;",
			"\t}",
			"\tconstexpr Matrix operator*(const Matrix &m) {",
			"\t\tassert(column == m.row);",
			"\t\tMatrix res(row, m.column);",
			"\t\tfor(int i=0;i<row;i++) for(int j=0;j<m.column;j++) for(int k=0;k<m.row;k++) res.t[i][j] += t[i][k] * m.t[k][j];",
			"\t\treturn res;",
			"\t}",
			"\tconstexpr Matrix &operator+=(const Matrix &m) {return *this = *this + m;}",
			"\tconstexpr Matrix &operator-=(const Matrix &m) {return *this = *this - m;}",
			"\tconstexpr Matrix &operator*=(const Matrix &m) {return *this = *this * m;}",
			"\tvoid set(int r, int c, T val) {t[r][c] = val;}",
			"\tT get(int r, int c) {return t[r][c];}",
			"\tMatrix pow(ll p) {",
			"\t\tassert(p > 0);",
			"\t\tif(p == 1) return *this;",
			"\t\tMatrix res = this->pow(p/2);",
			"\t\tres *= res;",
			"\t\tif(p % 2) res *= *this;",
			"\t\treturn res;",
			"\t}",
			"private:",
			"\tMatrix e(int sz) {",
			"\t\tMatrix res(sz, sz);",
			"\t\tfor(int i=0;i<sz;i++) res.t[i][i] = 1;",
			"\t}",
			"};"
		]
	},
	"FordFullkerson": {
		"prefix": "FordFullkerson",
		"body": [
			"struct FordFullkerson {",
			"\tstruct Edge {",
			"\t\tint to;",
			"\t\tint cap;",
			"\t\tint rev;",
			"\t\tEdge() : to{0}, cap{0}, rev{-1} {}",
			"\t\tEdge(int to, int cap, int rev) : to{to}, cap{cap}, rev{rev} {}",
			"\t\tEdge(const Edge &e) : to{e.to}, cap{e.cap}, rev{e.rev} {}",
			"\t};",
			"\tint sz;",
			"\tvector<vector<Edge>> graph;",
			"\tvector<bool> used;",
			"\tFordFullkerson(int sz) : sz{sz}, graph{vector<vector<Edge>>(sz, vector<Edge>())}, used{vector<bool>(sz, false)} {}",
			"\tvoid set_edge(int from, int to, int cap) { ",
			"\t\tint fsz = graph[from].size();",
			"\t\tint tsz = graph[to].size();",
			"\t\tgraph[from].push_back(Edge(to, cap, tsz));",
			"\t\tgraph[to].push_back(Edge(from, 0, fsz));",
			"\t}",
			"\tint flow(int start, int goal) {",
			"\t\tint res = 0;",
			"\t\twhile(true) {",
			"\t\t\tused.assign(sz, false);",
			"\t\t\tint f = dfs(start, inf, goal);",
			"\t\t\tif(!f) return res;",
			"\t\t\telse res += f;",
			"\t\t}",
			"\t\treturn 0;",
			"\t}",
			" private:",
			"\tint dfs(int now, int f, int goal) {",
			"\t\tif(now == goal) return f;",
			"\t\tused[now] = true;",
			"\t\tfor(auto &[to, cap, rev] : graph[now]) {",
			"\t\t\tif(used[to]) continue;",
			"\t\t\tif(!cap) continue;",
			"\t\t\tint res = dfs(to, min(f, cap), goal);",
			"\t\t\tif(!res) continue;",
			"\t\t\tgraph[to][rev].cap += res;",
			"\t\t\tcap -= res;",
			"\t\t\treturn res;",
			"\t\t}",
			"\t\treturn 0;",
			"\t}",
			"};",
		]
	},
	"Trie": {
		"prefix": "Trie",
		"body": [
			"struct Trie {",
			"\tstruct Node {",
			"\t\tvector<int> next;",
			"\t\tvector<ll> suf;",
			"\t\tchar c;",
			"\t\tint shared;",
			"\t\tint str_end;",
			"\t\tNode(char _c, int _shared) : c(_c), shared(_shared), str_end(0) {",
			"\t\t\tnext.assign(26, -1);",
			"\t\t\tsuf.assign(26, 0);",
			"\t\t}",
			"\t};",
			"\tvector<Node> nodes;",
			"\tint root;",
			"\tTrie() : root(0) {",
			"\t\tnodes.push_back(Node(0, 0));",
			"\t}",
			"\tvoid insert(const string &str) {",
			"\t\tint now = 0;",
			"\t\tnodes[now].shared++;",
			"\t\tfor(int i=0;i<str.length();i++) {",
			"\t\t\tint ntc = str[i] - 'a';",
			"\t\t\tint nt = nodes[now].next[ntc];",
			"\t\t\tif(nt < 0) {",
			"\t\t\t\tnodes[now].next[ntc] = nt = nodes.size();",
			"\t\t\t\tnodes.push_back(Node(str[i], 1));",
			"\t\t\t} else {",
			"\t\t\t\tnodes[nt].shared++;",
			"\t\t\t}",
			"\t\t\tnow = nt;",
			"\t\t}",
			"\t\tnodes[now].str_end++;",
			"\t}",
			"\tbool find(const string &str, bool prefix) {",
			"\t\tint now = 0;",
			"\t\tfor(int i=0;i<str.length();i++) {",
			"\t\t\tint ntc = str[i] - 'a';",
			"\t\t\tint next = nodes[now].next[ntc];",
			"\t\t\tif(next < 0) return false;",
			"\t\t\tnow = next;",
			"\t\t}",
			"\t\treturn prefix ? true : nodes[now].str_end > 0;",
			"\t}",
			"\tbool find(const string &str) {",
			"\t\treturn find(str, false);",
			"\t}",
			"\tbool find_prefix(const string &prefix) {",
			"\t\treturn find(prefix, true);",
			"\t}",
			"};"
		]
	},
	"MinCostFlow": {
		"prefix": "MinCostFlow",
		"body": [
			"template<typename Cap, typename Cost>",
			"struct MinCostFlow {",
			"\tconst Cost INF;",
			"\tstruct Edge {",
			"\t\tint to;",
			"\t\tCap cap;",
			"\t\tCost cost;",
			"\t\tint rev;",
			"\t};",
			"\tvector<vector<Edge>> graph;",
			"\tvector<Cost> potential, min_cost;",
			"\tvector<int> prevv, preve;",
			"\tMinCostFlow(int sz) : graph(sz), INF(numeric_limits<Cost>::max()) {}",
			"\tvoid add_edge(int from, int to, Cap cap, Cost cost) {",
			"\t\tgraph[from].emplace_back((Edge) {to, cap, cost, (int) graph[to].size()});",
			"\t\tgraph[to].emplace_back((Edge) {from, 0, -cost, (int) graph[from].size()-1});",
			"\t}",
			"\tCost min_cost_flow(int s, int t, Cap f) {",
			"\t\tint sz = (int)graph.size();",
			"\t\tCost ret = 0;",
			"\t\tusing Pi = pair<Cost, int>;",
			"\t\tpriority_queue<Pi, vector<Pi>, greater<Pi>> nt;",
			"\t\tpotential.assign(sz, 0);",
			"\t\tpreve.assign(sz, -1);",
			"\t\tprevv.assign(sz, -1);",
			"\t\twhile(f > 0) {",
			"\t\t\tmin_cost.assign(sz, INF);",
			"\t\t\tnt.emplace(0, s);",
			"\t\t\tmin_cost[s] = 0;",
			"\t\t\twhile(!nt.empty()) {",
			"\t\t\t\tauto [c, now] = nt.top();",
			"\t\t\t\tPi p = nt.top();",
			"\t\t\t\tnt.pop();",
			"\t\t\t\tif(min_cost[now] < c) continue;",
			"\t\t\t\tfor(int i=0;i<graph[now].size();i++) {",
			"\t\t\t\t\tEdge &e = graph[now][i];",
			"\t\t\t\t\tCost nextCost = min_cost[now] + e.cost + potential[now] - potential[e.to];",
			"\t\t\t\t\tif(e.cap > 0 && min_cost[e.to] > nextCost) {",
			"\t\t\t\t\t\tmin_cost[e.to] = nextCost;",
			"\t\t\t\t\t\tprevv[e.to] = p.second, preve[e.to] = i;",
			"\t\t\t\t\t\tnt.emplace(min_cost[e.to], e.to);",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\tif(min_cost[t] == INF) return -1;",
			"\t\t\tfor(int v=0;v<sz;v++) potential[v] += min_cost[v];",
			"\t\t\tCap addflow = f;",
			"\t\t\tfor(int v=t;v!=s;v=prevv[v]) addflow = min(addflow, graph[prevv[v]][preve[v]].cap);",
			"\t\t\tf -= addflow;",
			"\t\t\tret += addflow * potential[t];",
			"\t\t\tfor(int v = t; v != s; v = prevv[v]) {",
			"\t\t\t\tEdge &e = graph[prevv[v]][preve[v]];",
			"\t\t\t\te.cap -= addflow;",
			"\t\t\t\tgraph[v][e.rev].cap += addflow;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn ret;",
			"\t}",
			"};"
		]
	},
	"Rational": {
		"prefix": "Rational",
		"body": [
			"struct Rational {",
			"\tll numerator, denominator;",
			"\tconstexpr Rational() : numerator(0), denominator(1) {}",
			"\tconstexpr Rational(ll val) : numerator(val), denominator(1) {}",
			"\t// Rational(num, den) -> num / den",
			"\tconstexpr Rational(ll num, ll den) : numerator(num), denominator(den) {",
			"\t\tif(!denominator)  { numerator = 1; denominator = 0; return; }",
			"\t\tif(!numerator)    { numerator = 0; denominator = 1; return; }",
			"\t\tll g = gcd(numerator < 0 ? -numerator : numerator, denominator < 0 ? -denominator : denominator);",
			"\t\tnumerator /= g; denominator /= g;",
			"\t\tif(den < 0) { numerator = -numerator; denominator = -denominator; }",
			"\t}",
			"\tconstexpr Rational(const Rational &ratio) : numerator(ratio.numerator), denominator(ratio.denominator) {}",
			"\tconstexpr bool operator==(const Rational &rhs) const noexcept { return numerator == rhs.numerator && denominator == rhs.denominator; }",
			"\tconstexpr bool operator<(const Rational &rhs) const noexcept { return numerator * rhs.denominator < rhs.numerator * denominator; }",
			"\tconstexpr bool operator>(const Rational &rhs) const noexcept { return numerator * rhs.denominator > rhs.numerator * denominator; }",
			"\tconstexpr bool operator<=(const Rational &rhs) const noexcept { return numerator * rhs.denominator <= rhs.numerator * denominator; }",
			"\tconstexpr bool operator>=(const Rational &rhs) const noexcept { return numerator * rhs.denominator >= rhs.numerator * denominator; }",
			"\tconstexpr Rational operator-() const { return Rational(-numerator, denominator); }",
			"\tconstexpr Rational &operator+=(const Rational &rhs) noexcept {",
			"\t\tnumerator = numerator * rhs.denominator + rhs.numerator * denominator;",
			"\t\tdenominator *= rhs.denominator;",
			"\t\tll g = gcd(numerator, denominator);",
			"\t\tnumerator /= g, denominator /= g;",
			"\t\treturn *this;",
			"\t}",
			"\tconstexpr Rational &operator-=(const Rational &rhs) noexcept { return *this += -rhs; }",
			"\tconstexpr Rational &operator*=(const Rational &rhs) noexcept {",
			"\t\tif(rhs.is_zero()) { numerator = 0; denominator = 1; return *this; }",
			"\t\tif(rhs.is_inf())  { numerator = 1; denominator = 0; return *this; }",
			"\t\tnumerator *= rhs.numerator;",
			"\t\tdenominator *= rhs.denominator;",
			"\t\tll g = gcd(numerator, denominator);",
			"\t\tnumerator /= g, denominator /= g;",
			"\t\treturn *this;",
			"\t}",
			"\tconstexpr Rational &operator/=(const Rational &rhs) noexcept { return *this *= Rational(rhs.denominator, rhs.numerator); }",
			"\tconstexpr Rational operator+(const Rational &rhs) const noexcept { return Rational(*this) += rhs; }",
			"\tconstexpr Rational operator-(const Rational &rhs) const noexcept { return Rational(*this) -= rhs; }",
			"\tconstexpr Rational operator*(const Rational &rhs) const noexcept { return Rational(*this) *= rhs; }",
			"\tconstexpr Rational operator/(const Rational &rhs) const noexcept { return Rational(*this) /= rhs; }",
			"\tconstexpr inline bool is_zero() const { return numerator == 0; }",
			"\tconstexpr inline bool is_inf() const { return denominator == 0; }",
			"};"
		]
	}
}