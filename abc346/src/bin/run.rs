pub use __cargo_equip::prelude::*;

use iolib::*;

fn main() {
    scan!(h: usize, w: usize, m: usize, query: [(u8, u32, u32); m]);

    let mut rows = h;
    let mut cols = w;
    let mut rset = vec![false; h + 1];
    let mut cset = vec![false; w + 1];

    let mut res = vec![0; 200010];
    for (t, a, x) in query.into_iter().rev() {
        if t == 1 {
            if !rset[a as usize] {
                res[x as usize] += cols;
                rset[a as usize] = true;
                rows -= 1;
            }
        } else {
            if !cset[a as usize] {
                res[x as usize] += rows;
                cset[a as usize] = true;
                cols -= 1;
            }
        }
    }

    res[0] += rows * cols;

    let res = res
        .into_iter()
        .enumerate()
        .filter(|&(_, c)| c > 0)
        .collect::<Vec<_>>();
    putln!(res.len());
    for (color, number) in res {
        putitln!([color, number].into_iter(), sep = ' ');
    }
}

// The following code was expanded by `cargo-equip`.

///  # Bundled libraries
/// 
///  - `ds 0.1.0 (git+https://github.com/tayu0110/tayu-procon.git#8f9c90a28cfad37b51b646369aa00abcebfe3e68)`                          licensed under `CC0-1.0` as `crate::__cargo_equip::crates::ds`
///  - `ds 0.1.0 (path+██████████████████████████████████)`                                                  published in **missing** licensed under `CC0-1.0` as `crate::__cargo_equip::crates::__ds_0_1_0`
///  - `iolib 0.1.0 (path+█████████████████████████████████████)`                                            published in **missing** licensed under `CC0-1.0` as `crate::__cargo_equip::crates::iolib`
#[cfg_attr(any(), rustfmt::skip)]
#[allow(unused)]
mod __cargo_equip {
    pub(crate) mod crates {
        pub mod ds {mod btree_multiset{use std::{collections::BTreeMap,fmt::Debug,ops::RangeBounds};pub struct BTreeMultiSet<K>{len:usize,inner:BTreeMap<K,u32>,}impl<'a,K:Ord+Debug+Clone>BTreeMultiSet<K>{#[inline]pub fn new()->Self{Self{len:0,inner:BTreeMap::new()}}#[inline]pub fn insert(&mut self,key:K){*self.inner.entry(key).or_insert(0)+=1;self.len+=1;}#[inline]pub fn remove(&mut self,key:&K){if!self.inner.contains_key(key){return;}self.len-=1;if*self.inner.get(key).unwrap()==1{self.inner.remove(key);}else{*self.inner.get_mut(key).unwrap()-=1;}}#[inline]pub fn remove_all(&mut self,key:&K){self.len-=*self.inner.get(key).unwrap_or(&0)as usize;self.inner.remove(key);}#[inline]pub fn count(&mut self,key:&K)->usize{*self.inner.get(key).unwrap_or(&0)as usize}#[inline]pub fn len(&self)->usize{self.len}#[inline]pub fn clear(&mut self){self.inner.clear();self.len=0;}#[inline]pub fn has_duplicate(&self)->bool{self.len()!=self.inner.len()}#[inline]pub fn contains(&self,key:&K)->bool{self.inner.contains_key(key)}#[inline]pub fn first(&self)->Option<&K>{self.inner.iter().next().map(|(k,_)|k)}#[inline]pub fn get(&self,key:&K)->Option<&K>{self.inner.get_key_value(key).map(|(k,_)|k)}#[inline]pub fn is_empty(&self)->bool{self.inner.is_empty()}#[inline]pub fn last(&self)->Option<&K>{self.inner.iter().next_back().map(|(k,_)|k)}#[inline]pub fn iter(&'a self)->impl DoubleEndedIterator+'a{self.inner.iter().flat_map(|(k,&cnt)|(0..cnt).map(move|_|k))}#[inline]pub fn range<R:RangeBounds<K>>(&'a self,range:R)->impl DoubleEndedIterator+'a{self.inner.range(range).flat_map(|(k,&cnt)|(0..cnt).map(move|_|k))}}impl<K:Ord+Debug+Clone>Default for BTreeMultiSet<K>{fn default()->Self{Self::new()}}}mod cartesian_tree{#[derive(Debug,Clone)]pub struct CartesianTree{root:usize,par:Vec<u32>,left:Vec<u32>,right:Vec<u32>,}impl CartesianTree{pub fn new<T:Ord>(a:Vec<T>)->Self{let len=a.len();let mut res=Self{root:0,par:vec![u32::MAX;len],left:vec![u32::MAX;len],right:vec![u32::MAX;len],};let mut stack=vec![];for i in 0..len{let mut p=u32::MAX;while let Some(last)=stack.pop(){if a[last]<a[i]{stack.push(last);stack.push(i);res.par[i]=last as u32;res.right[last]=i as u32;break;}p=last as u32;}if stack.is_empty(){stack.push(i);}if p<u32::MAX{res.left[i]=p;res.par[p as usize]=i as u32;}}res.root=stack[0];res}pub const fn root(&self)->usize{self.root}pub fn left(&self,index:usize)->Option<usize>{(self.left[index]<u32::MAX).then_some(self.left[index]as usize)}pub fn right(&self,index:usize)->Option<usize>{(self.right[index]<u32::MAX).then_some(self.right[index]as usize)}pub fn parent(&self,index:usize)->Option<usize>{(self.par[index]<u32::MAX).then_some(self.par[index]as usize)}pub fn parlist(&self)->Vec<Option<usize>>{(0..self.par.len()).map(|i|self.parent(i)).collect()}}}mod fixed_ring_queue{#![allow(clippy::uninit_assumed_init)]use std::mem::MaybeUninit;pub struct FixedRingQueue<T,const SIZE:usize={1<<20}>{buf:[MaybeUninit<T>;SIZE],head:usize,tail:usize,empty:bool,}impl<T,const SIZE:usize>FixedRingQueue<T,SIZE>{const MASK:usize={assert!(1<<SIZE.trailing_zeros()==SIZE);SIZE-1};pub const fn new()->Self{Self{buf:unsafe{MaybeUninit::uninit().assume_init()},head:0,tail:0,empty:true,}}#[inline]pub fn is_empty(&self)->bool{self.empty}#[inline]pub fn is_full(&self)->bool{self.len()==SIZE}#[inline]pub fn len(&self)->usize{self.tail-self.head}#[inline]pub fn capacity(&self)->usize{SIZE}#[inline]pub fn clear(&mut self){self.head=0;self.tail=0;self.empty=true;}pub fn push(&mut self,val:T){debug_assert!(!self.is_full());unsafe{self.buf.as_mut_ptr().add(self.tail&Self::MASK).as_mut().unwrap_unchecked().write(val)};self.tail+=1;self.empty=false;}#[inline]pub unsafe fn pop_unchecked(&mut self)->T{let res=unsafe{std::ptr::replace(self.buf.as_mut_ptr().add(self.head&Self::MASK),MaybeUninit::uninit(),)};self.head+=1;self.empty=self.head==self.tail;res.assume_init()}#[inline]pub fn pop(&mut self)->Option<T>{(!self.is_empty()).then(||unsafe{self.pop_unchecked()})}}impl<T,const SIZE:usize>FromIterator<T>for FixedRingQueue<T,SIZE>{#[inline]fn from_iter<I:IntoIterator<Item=T>>(iter:I)->Self{let mut que=FixedRingQueue::new();iter.into_iter().for_each(|v|que.push(v));que}}impl<T,const SIZE:usize>Extend<T>for FixedRingQueue<T,SIZE>{#[inline]fn extend<I:IntoIterator<Item=T>>(&mut self,iter:I){iter.into_iter().for_each(|v|self.push(v));}}}mod interval_heap{#[derive(Debug,Clone)]pub struct IntervalHeap<T>{heap:Vec<T>,}impl<T>IntervalHeap<T>{pub const fn new()->Self{Self{heap:vec![]}}pub fn len(&self)->usize{self.heap.len()}pub fn is_empty(&self)->bool{self.heap.is_empty()}pub fn shrink_to_fit(&mut self){self.heap.shrink_to_fit();}pub fn with_capacity(capacity:usize)->Self{Self{heap:Vec::with_capacity(capacity)}}pub fn clear(&mut self){self.heap.clear();}}impl<T:Ord>IntervalHeap<T>{fn parent(&self,node:usize)->Option<usize>{(node>1).then_some((node>>1).wrapping_sub(1)&!1)}fn up_heap(&mut self,mut node:usize,root:usize)->usize{if(node|1)<self.len()&&self.heap[node&!1]>self.heap[node|1]{self.heap.swap(node&!1,node|1);node^=1;}let mut par=self.parent(node);while par.is_some()&&root<node&&self.heap[node]<self.heap[par.unwrap()]{self.heap.swap(par.unwrap(),node);node=par.unwrap();par=self.parent(node);}let mut par=self.parent(node);while par.is_some()&&root<node&&self.heap[par.unwrap()|1]<self.heap[node]{self.heap.swap(par.unwrap()|1,node);node=par.unwrap()|1;par=self.parent(node);}node}fn left_child(&self,node:usize)->Option<usize>{let res=node*2+2-(node&1);(res<self.len()).then_some(res)}fn right_child(&self,node:usize)->Option<usize>{let res=node*2+4-(node&1);(res<self.len()).then_some(res)}fn down_heap(&mut self,mut node:usize)->usize{if node&1!=0{while let Some(mut l)=self.left_child(node){if let Some(r)=self.right_child(node){l=if self.heap[l]>self.heap[r]{l}else{r};}if self.heap[node]<self.heap[l]{self.heap.swap(node,l);node=l;}else{break;}}}else{while let Some(mut l)=self.left_child(node){if let Some(r)=self.right_child(node){l=if self.heap[l]<self.heap[r]{l}else{r};}if self.heap[node]>self.heap[l]{self.heap.swap(node,l);node=l;}else{break;}}}node}pub fn from_vec(from:Vec<T>)->Self{let n=from.len();let mut res=Self{heap:from};let half=n>>1;for i in(0..half).rev(){let(l,r)=(i<<1,(i<<1)|1);if r<n&&res.heap[l]>res.heap[r]{res.heap.swap(l,r);}let k=res.down_heap(r);res.up_heap(k,r);let k=res.down_heap(l);res.up_heap(k,l);}res}pub fn push(&mut self,val:T){self.heap.push(val);if self.len()<2{return;}self.up_heap(self.len()-1,1);}pub fn pop_max(&mut self)->Option<T>{if self.len()<3{self.heap.pop()}else{let res=self.heap.swap_remove(1);let k=self.down_heap(1);self.up_heap(k,1);Some(res)}}pub fn pop_min(&mut self)->Option<T>{if self.len()<2{self.heap.pop()}else{let res=self.heap.swap_remove(0);let k=self.down_heap(0);self.up_heap(k,1);Some(res)}}pub fn max(&self)->Option<&T>{self.heap.get(1).or(self.heap.first())}pub fn min(&self)->Option<&T>{self.heap.first()}}}mod link_cut_tree{#![allow(clippy::collapsible_else_if,clippy::comparison_chain,clippy::non_canonical_clone_impl)]use super::MapMonoid;use std::fmt::Debug;use std::ops::{Deref,DerefMut};use std::ptr::NonNull;enum Edge<M:MapMonoid>{Light(NodeRef<M>),Heavy(NodeRef<M>),None,}#[derive(Debug,PartialEq)]struct Node<M:MapMonoid>{parent:Option<NodeRef<M>>,left:Option<NodeRef<M>>,right:Option<NodeRef<M>>,index:u32,val:M::M,sum:M::M,lazy:M::Act,}impl<M:MapMonoid>Node<M>{pub fn new(index:usize)->Self{Self{parent:None,left:None,right:None,index:index as u32,val:M::e(),sum:M::e(),lazy:M::id(),}}pub const fn index(&self)->usize{(self.index&!(1<<31))as usize}pub const fn is_reversed(&self)->bool{self.index>=(1<<31)}pub fn toggle(&mut self){self.index^=1<<31;M::reverse(&mut self.sum);(self.left,self.right)=(self.right,self.left);}fn propagate(&mut self){if let Some(mut left)=self.left{left.lazy=M::composite(&left.lazy,&self.lazy);left.sum=M::map(&left.sum,&self.lazy);if self.is_reversed(){left.toggle();}}if let Some(mut right)=self.right{right.lazy=M::composite(&right.lazy,&self.lazy);right.sum=M::map(&right.sum,&self.lazy);if self.is_reversed(){right.toggle();}}self.lazy=M::id();self.index=self.index()as u32;}fn update(&mut self){self.sum=match(self.left,self.right){(Some(l),Some(r))=>M::op(&M::op(&l.sum,&self.val),&r.sum),(Some(l),_)=>M::op(&l.sum,&self.val),(_,Some(r))=>M::op(&self.val,&r.sum),_=>M::map(&self.val,&M::id()),}}}struct NodeRef<M:MapMonoid>(NonNull<Node<M>>);impl<M:MapMonoid>NodeRef<M>{fn new(node:Node<M>)->Self{let reference=Box::leak(Box::new(node));Self(NonNull::new(reference as*mut _).unwrap())}fn connect_left(mut self,mut child:Self){assert_ne!(self.index,child.index);self.left=Some(child);child.parent=Some(self);}fn connect_right(mut self,mut child:Self){assert_ne!(self.index,child.index);self.right=Some(child);child.parent=Some(self);}fn weak_connect_parent(mut self,parent:Self){self.parent=Some(parent);}fn force_connect_parent(mut self,mut parent:Self){parent.right=Some(self);self.parent=Some(parent);}fn disconnect_left(mut self)->Option<Self>{if let Some(mut left)=self.left{left.parent=None;self.left=None;Some(left)}else{None}}fn disconnect_right(mut self)->Option<Self>{if let Some(mut right)=self.right{right.parent=None;self.right=None;Some(right)}else{None}}fn disconnect_parent(&mut self)->Edge<M>{if let Some(mut parent)=self.parent{match(parent.left,parent.right){(Some(l),_)if l==*self=>{parent.left=None;self.parent=None;}(_,Some(r))if r==*self=>{parent.right=None;self.parent=None;}_=>{self.parent=None;return Edge::Light(parent);}}Edge::Heavy(parent)}else{Edge::None}}fn rotate_left(mut self)->Self{let Some(mut right)=self.disconnect_right()else{return self;};if let Some(right_left)=right.disconnect_left(){self.connect_right(right_left);}self.update();let self_is_shallow=self.is_left_child();let par=self.disconnect_parent();right.connect_left(self);right.update();match par{Edge::Heavy(mut par)=>{if self_is_shallow{par.connect_left(right);}else{par.connect_right(right);}par.update();}Edge::Light(par)=>{right.weak_connect_parent(par);}Edge::None=>{}}right}fn rotate_right(mut self)->Self{let Some(mut left)=self.disconnect_left()else{return self;};if let Some(left_right)=left.disconnect_right(){self.connect_left(left_right);}self.update();let self_is_shallow=self.is_left_child();let par=self.disconnect_parent();left.connect_right(self);left.update();match par{Edge::Heavy(mut par)=>{if self_is_shallow{par.connect_left(left);}else{par.connect_right(left);}par.update();}Edge::Light(par)=>{left.weak_connect_parent(par);}Edge::None=>{}}left}fn splay(mut self){self.propagate();while!self.is_root(){let&(mut parent)=self.parent.as_ref().unwrap();if parent.is_root(){parent.propagate();self.propagate();if self.is_left_child(){parent.rotate_right();}else{parent.rotate_left();}return;}let&(mut grand_parent)=parent.parent.as_ref().unwrap();grand_parent.propagate();parent.propagate();self.propagate();if self.is_left_child()^parent.is_left_child(){if self.is_left_child(){parent.rotate_right();grand_parent.rotate_left();}else if self.is_right_child(){parent.rotate_left();grand_parent.rotate_right();}else{unreachable!()}}else{if self.is_left_child(){grand_parent.rotate_right();parent.rotate_right();}else if self.is_right_child(){grand_parent.rotate_left();parent.rotate_left();}else{unreachable!()}}}}fn is_left_child(self)->bool{self.parent.map_or(false,|p|p.left.map_or(false,|l|l.index==self.index))}fn is_right_child(self)->bool{self.parent.map_or(false,|p|p.right.map_or(false,|r|r.index==self.index))}fn is_root(self)->bool{self.parent.map_or(true,|p|{p.left.map_or(true,|s|s!=self)&&p.right.map_or(true,|d|d!=self)})}}impl<M:MapMonoid>Clone for NodeRef<M>{fn clone(&self)->Self{Self(self.0)}}impl<M:MapMonoid>Copy for NodeRef<M>{}impl<M:MapMonoid>PartialEq for NodeRef<M>{fn eq(&self,other:&Self)->bool{self.index==other.index}}impl<M:MapMonoid>Deref for NodeRef<M>{type Target=Node<M>;fn deref(&self)->&Self::Target{unsafe{self.0.as_ref()}}}impl<M:MapMonoid>DerefMut for NodeRef<M>{fn deref_mut(&mut self)->&mut Self::Target{unsafe{self.0.as_mut()}}}impl<M>Debug for NodeRef<M>where M:MapMonoid,M::M:Debug,M::Act:Debug,{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{write!(f,"NodeRef {{ index: {:?}, val: {:?}, sum: {:?}, lazy: {:?}, rev: {:?}, parent: {:?}, left: {:?}, right: {:?} }}",self.index(),self.val,self.sum,self.lazy,self.is_reversed(),self.parent.map(|p|p.index()),self.left,self.right)}}pub struct LinkCutTree<M:MapMonoid=DefaultZST>{nodes:Vec<NodeRef<M>>,}impl<M:MapMonoid>LinkCutTree<M>{pub fn new(size:usize)->Self{Self{nodes:(0..size).map(|i|NodeRef::new(Node::new(i))).collect(),}}pub fn from_edges(n:usize,edges:impl IntoIterator<Item=(usize,usize)>,)->Result<Self,&'static str>{let mut res=Self::new(n);for(u,v)in edges{res.link(u,v)?;}Ok(res)}pub fn expose(&self,index:usize)->usize{let mut now=self.nodes[index];now.splay();now.right=None;now.update();debug_assert!(now.is_root());while let Some(mut parent)=now.parent{parent.splay();debug_assert!(parent.is_root());now.force_connect_parent(parent);parent.update();now=parent;}self.nodes[index].splay();debug_assert!(self.nodes[index].parent.is_none());now.index()}pub fn root(&self,index:usize)->usize{self.expose(index);let mut now=self.nodes[index];while let Some(left)=now.left{now=left;}now.splay();now.index()}pub fn is_connected(&self,u:usize,v:usize)->bool{if u==v{return true;}self.expose(u);self.expose(v);self.nodes[u].parent.is_some()}pub fn link(&mut self,parent:usize,child:usize)->Result<(),&'static str>{if self.is_connected(parent,child){return Err("These nodes already belong to the same group.");}self.expose(parent);self.expose(child);self.nodes[child].force_connect_parent(self.nodes[parent]);self.nodes[parent].update();Ok(())}pub fn link_flat(&mut self,u:usize,v:usize)->Result<(),&'static str>{self.evert(v);self.link(u,v)?;Ok(())}pub fn cut(&mut self,new_root:usize){self.expose(new_root);self.nodes[new_root].disconnect_left();self.nodes[new_root].update();}pub fn try_cut(&mut self,u:usize,v:usize)->Result<(),&'static str>{self.evert(u);self.expose(v);if self.nodes[u].parent!=Some(self.nodes[v]){return Err("There is no direct connection between node `u` and node `v`.");}self.nodes[v].disconnect_left();self.nodes[v].update();Ok(())}pub fn evert(&mut self,new_root:usize){self.expose(new_root);assert!(self.nodes[new_root].right.is_none());self.nodes[new_root].toggle();self.nodes[new_root].propagate();}pub fn lca(&self,u:usize,v:usize)->Option<usize>{self.is_connected(u,v).then(||{self.expose(u);self.expose(v)})}pub fn set(&mut self,index:usize,val:M::M){self.expose(index);self.nodes[index].val=val;self.nodes[index].update();}pub fn val(&self,index:usize)->Option<&M::M>{self.nodes.get(index).as_ref().map(|n|&n.val)}pub fn update_by(&mut self,index:usize,f:impl Fn(&M::M)->M::M){let new=f(&self.nodes[index].val);self.set(index,new);}pub fn fold(&mut self,u:usize,v:usize)->Option<&M::M>{self.is_connected(u,v).then(||{self.evert(u);assert!(self.nodes[u].is_root());self.expose(v);&self.nodes[v].sum})}pub fn parent(&self,node:usize)->Option<usize>{self.expose(node);let mut par=self.nodes[node].left?;while let Some(r)=par.right{par=r;}Some(par.index())}}impl<M:MapMonoid>Drop for LinkCutTree<M>{fn drop(&mut self){self.nodes.iter_mut().for_each(|p|unsafe{p.parent=None;p.left=None;p.right=None;let _=Box::from_raw(p.0.as_ptr());});self.nodes.clear();}}impl<M>Debug for LinkCutTree<M>where M:MapMonoid,M::M:Debug,M::Act:Debug,{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{write!(f,"LinkCutTree {{ nodes: {:?} }}",self.nodes)}}#[derive(Debug,Clone,Copy,PartialEq,Eq)]pub struct DefaultZST;impl MapMonoid for DefaultZST{type M=DefaultZST;type Act=DefaultZST;fn e()->Self::M{DefaultZST}fn op(_:&Self::M,_:&Self::M)->Self::M{DefaultZST}fn map(_:&Self::M,_:&Self::Act)->Self::M{DefaultZST}fn id()->Self::Act{DefaultZST}fn composite(_:&Self::Act,_:&Self::Act)->Self::Act{DefaultZST}}}pub use btree_multiset::*;pub use cartesian_tree::*;pub use fixed_ring_queue::*;pub use interval_heap::*;pub use link_cut_tree::*;pub trait MapMonoid{type M;type Act;fn e()->Self::M;fn op(l:&Self::M,r:&Self::M)->Self::M;fn id()->Self::Act;fn composite(l:&Self::Act,r:&Self::Act)->Self::Act;fn map(m:&Self::M,act:&Self::Act)->Self::M;fn reverse(m:&mut Self::M){let _=m;}}}
        pub mod __ds_0_1_0 {mod fixed_ring_queue{#![allow(clippy::uninit_assumed_init)]use std::mem::MaybeUninit;pub struct FixedRingQueue<T,const SIZE:usize={1<<20}>{buf:[MaybeUninit<T>;SIZE],head:usize,tail:usize,empty:bool,}impl<T,const SIZE:usize>FixedRingQueue<T,SIZE>{const MASK:usize={assert!(1<<SIZE.trailing_zeros()==SIZE);SIZE-1};pub const fn new()->Self{Self{buf:unsafe{MaybeUninit::uninit().assume_init()},head:0,tail:0,empty:true,}}#[inline]pub fn is_empty(&self)->bool{self.empty}#[inline]pub fn is_full(&self)->bool{self.len()==SIZE}#[inline]pub fn len(&self)->usize{self.tail-self.head}#[inline]pub fn capacity(&self)->usize{SIZE}#[inline]pub fn clear(&mut self){self.head=0;self.tail=0;self.empty=true;}pub fn push(&mut self,val:T){debug_assert!(!self.is_full());unsafe{self.buf.as_mut_ptr().add(self.tail&Self::MASK).as_mut().unwrap_unchecked().write(val)};self.tail+=1;self.empty=false;}#[inline]pub unsafe fn pop_unchecked(&mut self)->T{let res=unsafe{std::ptr::replace(self.buf.as_mut_ptr().add(self.head&Self::MASK),MaybeUninit::uninit(),)};self.head+=1;self.empty=self.head==self.tail;res.assume_init()}#[inline]pub fn pop(&mut self)->Option<T>{(!self.is_empty()).then(||unsafe{self.pop_unchecked()})}}impl<T,const SIZE:usize>FromIterator<T>for FixedRingQueue<T,SIZE>{#[inline]fn from_iter<I:IntoIterator<Item=T>>(iter:I)->Self{let mut que=FixedRingQueue::new();iter.into_iter().for_each(|v|que.push(v));que}}impl<T,const SIZE:usize>Extend<T>for FixedRingQueue<T,SIZE>{#[inline]fn extend<I:IntoIterator<Item=T>>(&mut self,iter:I){iter.into_iter().for_each(|v|self.push(v));}}}pub use fixed_ring_queue::*;pub trait MapMonoid{type M;type Act;fn e()->Self::M;fn op(l:&Self::M,r:&Self::M)->Self::M;fn id()->Self::Act;fn composite(l:&Self::Act,r:&Self::Act)->Self::Act;fn map(m:&Self::M,act:&Self::Act)->Self::M;fn reverse(m:&mut Self::M){let _=m;}}}
        pub mod iolib {use crate::__cargo_equip::preludes::iolib::*;pub use crate::__cargo_equip::macros::iolib::*;#[cfg(target_family="unix")]mod ext{use crate::__cargo_equip::preludes::iolib::*;use std::ffi::{c_int,c_long,c_void};extern "C"{pub fn mmap(addr:*mut c_void,length:usize,prot:c_int,flags:c_int,fd:c_int,offset:c_long,)->*mut c_void;}pub const PROT_READ:i32=1;pub const MAP_PRIVATE:i32=2;}mod input{use crate::__cargo_equip::preludes::iolib::*;#[cfg(target_family="unix")]use super::ext::{mmap,MAP_PRIVATE,PROT_READ};use super::parse_number::{parse16c,parse4c,parse4lec,parse8c,parse8lec};use ds::FixedRingQueue;#[cfg(target_arch="x86_64")]use std::arch::x86_64::{__m256i,_mm256_cmpgt_epi8,_mm256_loadu_si256,_mm256_movemask_epi8};use std::fs::File;use std::io::Read;use std::mem::transmute;#[cfg(target_family="unix")]use std::os::unix::io::FromRawFd;#[cfg(target_family="unix")]use std::ptr::{null_mut,slice_from_raw_parts_mut};fn parse_u64(buf:&[u8])->u64{let offset=buf.len();unsafe{if offset<8{buf.iter().fold(0u32,|s,&v|s*10+v as u32-b'0' as u32)as u64}else if offset==8{parse8c(buf.try_into().unwrap_unchecked())}else if offset==12{let upper=parse4c(buf[..4].try_into().unwrap_unchecked());let lower=parse8c(buf[4..].try_into().unwrap_unchecked());upper*100_000_000+lower}else if offset<16{let rem=offset-8;let upper=parse8lec(buf[..8].try_into().unwrap_unchecked(),rem as u8);let lower=parse8c(buf[rem..].try_into().unwrap_unchecked());upper*100_000_000+lower}else if offset==16{parse16c(buf)}else if offset==20{let upper=buf[..4].iter().fold(0u32,|s,&v|s*10+v as u32-b'0' as u32)as u64;let lower=parse16c(&buf[4..]);upper*10_000_000_000_000_000+lower}else{let rem=offset-16;let upper=parse4lec(buf[..4].try_into().unwrap_unchecked(),rem as u8);let lower=parse16c(&buf[rem..]);upper*10_000_000_000_000_000+lower}}}pub trait Readable{fn read(src:&mut FastInput)->Self;}impl Readable for char{fn read(src:&mut FastInput)->Self{src.read_char()}}impl Readable for String{fn read(src:&mut FastInput)->Self{src.read_string()}}macro_rules!impl_readable_integer{($({$t:ty,$ut:ty}),*)=>{$(impl Readable for$ut{#[inline]fn read(src:&mut FastInput)->$ut{let buf=src.source.next();parse_u64(buf)as$ut}}impl Readable for$t{#[inline]fn read(src:&mut FastInput)->$t{let buf=src.source.next();if buf[0]==b'-'{-(parse_u64(&buf[1..])as$t)}else{parse_u64(buf)as$t}}})*};}impl_readable_integer!({i8,u8},{i16,u16},{i32,u32},{i64,u64},{i128,u128},{isize,usize});macro_rules!impl_readable_float{($($t:ty)*)=>{$(impl Readable for$t{fn read(src:&mut FastInput)->$t{src.read_string().parse().unwrap()}})*};}impl_readable_float!(f32 f64);pub struct FastInput{source:Source,}impl FastInput{pub fn new()->Self{Self{source:Source::new()}}#[inline]pub fn read<R:Readable>(&mut self)->R{R::read(self)}#[inline]pub fn read_char(&mut self)->char{let c=self.source.next();assert_eq!(c.len(),1);char::from_u32(c[0]as u32).unwrap()}#[inline]pub fn read_string(&mut self)->String{unsafe{String::from_utf8_unchecked(self.source.next().to_vec())}}}static mut INPUT:*mut FastInput=0 as*mut FastInput;static mut STDIN_SOURCE:fn()->&'static mut FastInput=init;#[inline]fn init()->&'static mut FastInput{unsafe{INPUT=Box::leak(Box::new(FastInput::new()));STDIN_SOURCE=get_input;}get_input()}#[inline]fn get_input()->&'static mut FastInput{unsafe{INPUT.as_mut().unwrap_unchecked()}}#[inline]pub fn get_stdin_source()->&'static mut FastInput{unsafe{STDIN_SOURCE()}}struct Source{head:usize,next:Option<usize>,_file:Option<File>,len:usize,buf:Box<[u8]>,queue:FixedRingQueue<(usize,usize),{1<<4}>,}impl Source{const SEPARATORS:__m256i=unsafe{transmute([0x21i8;32])};#[cfg(target_family="unix")]fn new()->Self{let mut stdin=unsafe{File::from_raw_fd(0)};let meta=stdin.metadata().unwrap();let(buf,len)=if meta.is_file(){let len=meta.len()as usize+32;let mapping=unsafe{mmap(null_mut()as _,len,PROT_READ,MAP_PRIVATE,0,0)};let res=slice_from_raw_parts_mut(mapping as*mut u8,len);(unsafe{Box::from_raw(res)},meta.len()as usize)}else{let mut buf=Vec::with_capacity(1<<18);stdin.read_to_end(&mut buf).unwrap();let len=buf.len();buf.resize(buf.len()+32,b' ');(buf.into_boxed_slice(),len)};Self{head:0,next:None,_file:Some(stdin),len,buf,queue:FixedRingQueue::<(usize,usize),{1<<4}>::new(),}}#[cfg(not(target_family="unix"))]fn new()->Self{let mut buf=Vec::with_capacity(1<<18);std::io::stdin().lock().read_to_end(&mut buf).ok();let len=buf.len();buf.resize(buf.len()+32,b' ');Self{head:0,next:None,_file:None,len,buf:buf.into_boxed_slice(),queue:FixedRingQueue::<(usize,usize),{1<<4}>::new(),}}fn next(&mut self)->&[u8]{if let Some((head,tail))=self.queue.pop(){return&self.buf[head..tail];}let(head,tail)=unsafe{self.fill()};&self.buf[head..tail]}#[target_feature(enable="avx2")]unsafe fn fill(&mut self)->(usize,usize){let mut head=usize::MAX;if let Some(next)=self.next{head=next;self.next=None;}while self.queue.is_empty()&&self.head+32<=self.len{let bytes=_mm256_loadu_si256(self.buf[self.head..].as_ptr()as _);let gt=_mm256_cmpgt_epi8(Self::SEPARATORS,bytes);let mut b=_mm256_movemask_epi8(gt)as u32;let mut now=self.head;if b==0&&head==usize::MAX{head=self.head;}if!(head!=usize::MAX&&b==u32::MAX){let lowlimit=((1u64<<b.reverse_bits().trailing_ones())-1)as u32;while b>lowlimit{if head==usize::MAX{let tr=b.trailing_ones();b>>=tr;now+=tr as usize;head=now;}else{let tr=b.trailing_zeros();b>>=tr;now+=tr as usize;self.queue.push((head,now));head=usize::MAX;}}}self.head+=32;}if self.queue.is_empty(){if head==usize::MAX{while self.buf[self.head].is_ascii_whitespace(){self.head+=1;}head=self.head;}while self.head<self.len&&!self.buf[self.head].is_ascii_whitespace(){self.head+=1;}self.queue.push((head,self.head));head=usize::MAX;}if head<usize::MAX{self.next=Some(head);}self.queue.pop_unchecked()}}}mod output{#![allow(clippy::ptr_arg)]use crate::__cargo_equip::preludes::iolib::*;use std::{cell::RefCell,io::{StdoutLock,Write},ptr::{addr_of_mut,copy_nonoverlapping},};const BUF_SIZE:usize=1<<20;pub trait Writable{fn write(&self,dest:&mut FastOutput);}impl Writable for char{fn write(&self,dest:&mut FastOutput){dest.store_byte(*self as u8)}}impl Writable for String{fn write(&self,dest:&mut FastOutput){dest.store_string(self)}}impl Writable for str{fn write(&self,dest:&mut FastOutput){dest.store_string(self)}}impl Writable for&str{fn write(&self,dest:&mut FastOutput){dest.store_string(self)}}const LUT:[u8;40000]={let mut lut=[0;40000];let mut i=0;while i<10000{lut[i*4]=(i/1000)as u8+b'0';lut[i*4+1]=(i%1000/100)as u8+b'0';lut[i*4+2]=(i%100/10)as u8+b'0';lut[i*4+3]=(i%10)as u8+b'0';i+=1;}lut};macro_rules!impl_writable_integer{($({$t:ty,$ut:ty,$size:expr})*)=>{$(impl Writable for$ut{fn write(&self,dest:&mut FastOutput){if self==&0{dest.store_byte(b'0');return;}let mut keep=[0u16;$size];let mut head=0;let mut now=*self as u64;while now>=10000_0000{let rem=now%10000_0000;let upper=rem/10000;let lower=rem%10000;keep[head]=lower as u16;keep[head+1]=upper as u16;head+=2;now/=10000_0000;}if now>=10000{let rem=now%10000;keep[head]=rem as u16;head+=1;now/=10000;}let now=now as u16;let log=now.ilog10()as usize;let buf=dest.borrow_buffer((head<<2)+log+1);if log==0{buf[0]=now as u8+b'0';}else{let n=(now as usize)*4+3-log;buf[..log+1].copy_from_slice(&LUT[n..n+log+1]);}let mut cursor=log+1;while head>0{head-=1;let n=keep[head]as usize*4;buf[cursor..cursor+4].copy_from_slice(&LUT[n..n+4]);cursor+=4;}}}impl Writable for$t{fn write(&self,dest:&mut FastOutput){if self<&0{'-'.write(dest);}(self.abs()as$ut).write(dest);}})*};}impl_writable_integer!({i8,u8,1}{i16,u16,2}{i32,u32,3}{i64,u64,5}{i128,u128,10}{isize,usize,5});macro_rules!impl_writable_float{($($t:ty)*)=>{$(impl Writable for$t{fn write(&self,dest:&mut FastOutput){format!("{}",self).write(dest)}})*};}impl_writable_float!(f32 f64);impl<T:Clone+Writable>Writable for Vec<T>{fn write(&self,dest:&mut FastOutput){dest.store_vec(self,'\n')}}pub struct FastOutput<'a>{tail:usize,buf:[u8;BUF_SIZE],dest:*mut StdoutLock<'a>,}impl<'a>FastOutput<'a>{#[inline]pub const fn new()->Self{Self{tail:0,buf:[0;BUF_SIZE],dest:0 as*mut StdoutLock<'a>}}#[inline]fn init(&mut self){let stdout=Box::leak::<'a>(Box::new(std::io::stdout()));self.dest=Box::leak::<'a>(Box::new(stdout.lock()));}#[inline]pub fn flush(&mut self){unsafe{self.dest.as_mut().unwrap_unchecked().write_all(&self.buf[..self.tail]).unwrap_unchecked();}self.tail=0;}pub fn borrow_buffer(&mut self,size:usize)->&mut[u8]{if BUF_SIZE-self.tail<=size{self.flush();}self.tail+=size;&mut self.buf[self.tail-size..self.tail]}#[inline]pub fn store(&mut self,bytes:&[u8]){if bytes.len()>=BUF_SIZE{self.flush();unsafe{self.dest.as_mut().unwrap_unchecked().write_all(bytes).unwrap_unchecked()}self.tail=0;return;}if bytes.len()<BUF_SIZE-self.tail{unsafe{copy_nonoverlapping(bytes.as_ptr(),self.buf[self.tail..].as_mut_ptr(),bytes.len(),)}self.tail+=bytes.len();}else{self.flush();unsafe{copy_nonoverlapping(bytes[..].as_ptr(),self.buf[..bytes.len()].as_mut_ptr(),bytes.len(),)}self.tail=bytes.len();}}#[inline]pub fn store_byte(&mut self,b:u8){self.buf[self.tail]=b;self.tail+=1;if self.tail==BUF_SIZE{self.flush();}}#[inline]pub fn store_string(&mut self,s:&str){let bytes=s.as_bytes();self.store(bytes);}#[inline]pub fn write<T:Writable>(&mut self,data:T){data.write(self)}#[inline]pub fn store_vec<T:Clone+Writable>(&mut self,v:&Vec<T>,delim:char){if v.is_empty(){return;}v[0].write(self);for v in v.iter().skip(1){delim.write(self);v.write(self);}}#[inline]pub fn store_iter<I:Iterator<Item=T>,T:Writable>(&mut self,mut iter:I,delim:char){if let Some(n)=iter.next(){n.write(self);}for n in iter{delim.write(self);n.write(self);}}}struct DummyForFlush(u32);impl Drop for DummyForFlush{fn drop(&mut self){unsafe{OUTPUT.flush();}}}static mut OUTPUT:FastOutput<'static> =FastOutput::new();static mut STDOUTSOURCE:fn()->&'static mut FastOutput<'static> =init;thread_local!{static DUMMY:RefCell<DummyForFlush> =const{RefCell::new(DummyForFlush(0))};}fn init()->&'static mut FastOutput<'static>{DUMMY.with(|d|{unsafe{core::ptr::write_volatile((&mut d.borrow_mut().0)as*const _ as*mut _,32)};});unsafe{STDOUTSOURCE=get_output;}let res=get_output();res.init();res}fn get_output()->&'static mut FastOutput<'static>{unsafe{addr_of_mut!(OUTPUT).as_mut().unwrap()}}pub fn get_output_source()->&'static mut FastOutput<'static>{unsafe{STDOUTSOURCE()}}}mod parse_number{use crate::__cargo_equip::preludes::iolib::*;fn parse4c_core(mut chunk:u32)->u64{let lower=(chunk&0x0f000f00)>>8;let upper=(chunk&0x000f000f)*10;chunk=lower+upper;let lower=(chunk&0x00ff0000)>>16;let upper=(chunk&0x000000ff)*100;(lower+upper)as u64}pub(in crate::__cargo_equip::crates::iolib)unsafe fn parse4c(buf:[u8;4])->u64{let chunk=u32::from_le_bytes(buf);parse4c_core(chunk)}pub(in crate::__cargo_equip::crates::iolib)unsafe fn parse4lec(buf:[u8;4],digits:u8)->u64{let offset=(4-digits)<<3;let chunk=u32::from_le_bytes(buf).wrapping_shl(offset as u32);parse4c_core(chunk)}fn parse8c_core(mut chunk:u64)->u64{let lower=(chunk&0x0f000f000f000f00)>>8;let upper=(chunk&0x000f000f000f000f)*10;chunk=lower+upper;let lower=(chunk&0x00ff000000ff0000)>>16;let upper=(chunk&0x000000ff000000ff)*100;chunk=lower+upper;let lower=(chunk&0x0000ffff00000000)>>32;let upper=(chunk&0x000000000000ffff)*10000;lower+upper}pub(in crate::__cargo_equip::crates::iolib)unsafe fn parse8c(buf:[u8;8])->u64{let chunk=u64::from_le_bytes(buf);parse8c_core(chunk)}pub(in crate::__cargo_equip::crates::iolib)unsafe fn parse8lec(buf:[u8;8],digits:u8)->u64{let offset=(8-digits)<<3;let chunk=u64::from_le_bytes(buf).wrapping_shl(offset as u32);parse8c_core(chunk)}#[cfg(not(target_arch="x86_64"))]fn parse16c_core(mut chunk:u128)->u64{let lower=(chunk&0x0f000f000f000f000f000f000f000f00)>>8;let upper=(chunk&0x000f000f000f000f000f000f000f000f)*10;chunk=lower+upper;let lower=(chunk&0x00ff000000ff000000ff000000ff0000)>>16;let upper=(chunk&0x000000ff000000ff000000ff000000ff)*100;chunk=lower+upper;let lower=(chunk&0x0000ffff000000000000ffff00000000)>>32;let upper=(chunk&0x000000000000ffff000000000000ffff)*10000;chunk=lower+upper;let lower=(chunk>>64)as u64&0x00000000ffffffff;let upper=(chunk as u64&0x00000000ffffffff)*10000_0000;lower+upper}#[cfg(not(target_arch="x86_64"))]pub(in crate::__cargo_equip::crates::iolib)unsafe fn parse16c(buf:&[u8])->u64{let buf:[u8;16]=buf.try_into().unwrap();let chunk=u128::from_le_bytes(buf);parse16c_core(chunk)}#[cfg(not(target_arch="x86_64"))]pub(in crate::__cargo_equip::crates::iolib)unsafe fn parse16lec(buf:&[u8],digits:u8)->u64{let buf:[u8;16]=buf.try_into().unwrap();let offset=(16-digits as u32)<<3;let chunk=u128::from_le_bytes(buf).wrapping_shl(offset);parse16c_core(chunk)}#[cfg(target_arch="x86_64")]use std::arch::x86_64::{__m128i,_mm_lddqu_si128,_mm_madd_epi16,_mm_maddubs_epi16,_mm_packus_epi32,_mm_storeu_si128,_mm_sub_epi8,};use std::mem::transmute;const ZEROS:__m128i=unsafe{transmute([b'0';16])};const TEN:__m128i=unsafe{transmute([10u8,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1])};const HUN:__m128i=unsafe{transmute([100u8,0,1,0,100,0,1,0,100,0,1,0,100,0,1,0])};const THO:__m128i=unsafe{transmute([16u8,39,1,0,16,39,1,0,0,0,0,0,0,0,0,0])};#[cfg(target_arch="x86_64")]#[target_feature(enable="sse2")]#[target_feature(enable="sse3")]#[target_feature(enable="ssse3")]#[target_feature(enable="sse4.1")]#[target_feature(enable="sse4.2")]pub(in crate::__cargo_equip::crates::iolib)unsafe fn parse16c(buf:&[u8])->u64{let mut chunk=_mm_lddqu_si128(buf.as_ptr()as _);chunk=_mm_madd_epi16(_mm_maddubs_epi16(_mm_sub_epi8(chunk,ZEROS),TEN),HUN);chunk=_mm_madd_epi16(_mm_packus_epi32(chunk,chunk),THO);let mut buf=[0u8;16];_mm_storeu_si128(buf.as_mut_ptr()as _,chunk);let res=u64::from_le_bytes(buf[..8].try_into().unwrap());((res&0xffffffff)*100_000_000)+(res>>32)}}pub use input::{get_stdin_source,FastInput,Readable};pub use output::get_output_source;#[macro_export]macro_rules!__cargo_equip_macro_def_iolib_read_value{(@kind[[$($kind:tt)*]])=>{$crate::__cargo_equip::crates::iolib::read_value!(@array@kind[]@rest$($kind)*)};(@array@kind[$($kind:tt)*]@rest;$($rest:tt)*)=>{$crate::__cargo_equip::crates::iolib::read_value!(@array@kind[$($kind)*]@len$($rest)*)};(@array@kind[$($kind:tt)*]@rest$t:tt$($rest:tt)*)=>{$crate::__cargo_equip::crates::iolib::read_value!(@array@kind[$($kind)*$t]@rest$($rest)*)};(@array@kind[$($kind:tt)*]@len$($len:tt)*)=>{{let len=$($len)*;(0..len).map(|_|$crate::__cargo_equip::crates::iolib::read_value!(@kind[$($kind)*])).collect::<Vec<_>>()}};(@kind[($($kind:tt)*)])=>{$crate::__cargo_equip::crates::iolib::read_value!(@tuple@kind[]@current[]@rest$($kind)*)};(@tuple@kind[$([$($kind:tt)*])*]@current[]@rest)=>{($($crate::__cargo_equip::crates::iolib::read_value!(@kind[$($kind)*]),)*)};(@tuple@kind[$([$($kind:tt)*])*]@current[$($current:tt)*]@rest)=>{$crate::__cargo_equip::crates::iolib::read_value!(@tuple@kind[$([$($kind)*])*[$($current)*]]@current[]@rest)};(@tuple@kind[$([$($kind:tt)*])*]@current[$($current:tt)*]@rest,$($rest:tt)*)=>{$crate::__cargo_equip::crates::iolib::read_value!(@tuple@kind[$([$($kind)*])*[$($current)*]]@current[]@rest$($rest)*)};(@tuple@kind[$([$($kind:tt)*])*]@current[$($current:tt)*]@rest$t:tt$($rest:tt)*)=>{$crate::__cargo_equip::crates::iolib::read_value!(@tuple@kind[$([$($kind)*])*]@current[$($current)*$t]@rest$($rest)*)};(@kind[$t:tt])=>{$crate::__cargo_equip::crates::iolib::get_stdin_source().read::<$t>()};}macro_rules!read_value{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_iolib_read_value!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_iolib_scan{(@rest)=>{};(@rest mut$($rest:tt)*)=>{$crate::__cargo_equip::crates::iolib::scan!([mut]@rest$($rest)*)};(@rest$($rest:tt)*)=>{$crate::__cargo_equip::crates::iolib::scan!([]@rest$($rest)*)};([$($mut:tt)?]@rest$var:tt:$($rest:tt)*)=>{$crate::__cargo_equip::crates::iolib::scan!([$($mut)*]@var$var@kind[]@rest$($rest)*);};([$($mut:tt)?]@var$var:tt@kind[$($kind:tt)*]@rest)=>{let$($mut)*$var=$crate::__cargo_equip::crates::iolib::read_value!(@kind[$($kind)*]);};([$($mut:tt)?]@var$var:tt@kind[$($kind:tt)*]@rest,$($rest:tt)*)=>{$crate::__cargo_equip::crates::iolib::scan!([$($mut)*]@var$var@kind[$($kind)*]@rest);$crate::__cargo_equip::crates::iolib::scan!(@rest$($rest)*);};([$($mut:tt)?]@var$var:tt@kind[$($kind:tt)*]@rest$t:tt$($rest:tt)*)=>{$crate::__cargo_equip::crates::iolib::scan!([$($mut)*]@var$var@kind[$($kind)*$t]@rest$($rest)*);};($($rest:tt)*)=>{$crate::__cargo_equip::crates::iolib::scan!(@rest$($rest)*);};}macro_rules!scan{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_iolib_scan!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_iolib_put{()=>{};($t:expr)=>{$crate::__cargo_equip::crates::iolib::get_output_source().write($t);};($t:expr$(,$rest:tt)*)=>{$crate::__cargo_equip::crates::iolib::put!($t);$crate::__cargo_equip::crates::iolib::put!(' ');$crate::__cargo_equip::crates::iolib::put!($($rest)*);};}macro_rules!put{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_iolib_put!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_iolib_putln{()=>{$crate::__cargo_equip::crates::iolib::put!('\n');};($t:expr)=>{$crate::__cargo_equip::crates::iolib::put!($t);$crate::__cargo_equip::crates::iolib::put!('\n');};($t:expr$(,$rest:tt)*)=>{$crate::__cargo_equip::crates::iolib::put!($t);$crate::__cargo_equip::crates::iolib::put!(' ');$crate::__cargo_equip::crates::iolib::put!($($rest)*);$crate::__cargo_equip::crates::iolib::put!('\n');};}macro_rules!putln{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_iolib_putln!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_iolib_putv{($t:expr,sep=$delim:expr)=>{$crate::__cargo_equip::crates::iolib::get_output_source().store_vec(&$t,$delim);};($t:expr)=>{$crate::__cargo_equip::crates::iolib::putv!($t,sep='\n');};}macro_rules!putv{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_iolib_putv!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_iolib_putvln{($t:expr,sep=$delim:expr)=>{$crate::__cargo_equip::crates::iolib::putv!($t,sep=$delim);$crate::__cargo_equip::crates::iolib::putln!();};($t:expr)=>{$crate::__cargo_equip::crates::iolib::putvln!($t,sep='\n');};}macro_rules!putvln{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_iolib_putvln!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_iolib_putit{($t:expr,sep=$delim:expr)=>{$crate::__cargo_equip::crates::iolib::get_output_source().store_iter($t,$delim);};($t:expr)=>{$crate::__cargo_equip::crates::iolib::putit!($t,sep='\n');};}macro_rules!putit{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_iolib_putit!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_iolib_putitln{($t:expr,sep=$delim:expr)=>{$crate::__cargo_equip::crates::iolib::putit!($t,sep=$delim);$crate::__cargo_equip::crates::iolib::putln!();};($t:expr)=>{$crate::__cargo_equip::crates::iolib::putitln!($t,sep='\n');};}macro_rules!putitln{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_iolib_putitln!{$($tt)*})}}
    }

    pub(crate) mod macros {
        pub mod ds {}
        pub mod __ds_0_1_0 {}
        pub mod iolib {pub use crate::{__cargo_equip_macro_def_iolib_put as put,__cargo_equip_macro_def_iolib_putit as putit,__cargo_equip_macro_def_iolib_putitln as putitln,__cargo_equip_macro_def_iolib_putln as putln,__cargo_equip_macro_def_iolib_putv as putv,__cargo_equip_macro_def_iolib_putvln as putvln,__cargo_equip_macro_def_iolib_read_value as read_value,__cargo_equip_macro_def_iolib_scan as scan};}
    }

    pub(crate) mod prelude {pub use crate::__cargo_equip::crates::*;}

    mod preludes {
        pub mod ds {}
        pub mod __ds_0_1_0 {}
        pub mod iolib {pub(in crate::__cargo_equip)use crate::__cargo_equip::crates::__ds_0_1_0 as ds;}
    }
}
